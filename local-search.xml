<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ICS Malloc Lab Report</title>
    <link href="/2023/01/16/ICS-Malloc-Lab-Report/"/>
    <url>/2023/01/16/ICS-Malloc-Lab-Report/</url>
    
    <content type="html"><![CDATA[<h1 id="MALLOC-LAB-实验报告"><a href="#MALLOC-LAB-实验报告" class="headerlink" title="MALLOC LAB 实验报告"></a>MALLOC LAB 实验报告</h1><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="V1-Implicit-free-list-隐式空闲链表"><a href="#V1-Implicit-free-list-隐式空闲链表" class="headerlink" title="V1 Implicit free list 隐式空闲链表"></a>V1 Implicit free list 隐式空闲链表</h3><p>这是csapp课本上介绍最为详细的一种方法，也是最简单的一种实现方法。</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>使用header+payload|padding+footer，其中header和footer各占8字节，由于Size满足16字节对齐，因此低4位均为0，可以用最低位置a表示此区域是否为空</p><p><img src="/img/ICS\image-20230113161222265.png" alt="" style="zoom: 50%;" /></p><p>通过每个块的起始位置和对应的Size大小，可以找到相邻的块儿，这样就构成了一条双向链表，可以在线性正比于块总数的时间内查找</p><p><img src="/img/ICS\image-20230113162952533.png" alt="" style="zoom: 50%;" /></p><p>起始被染成灰色的块为<strong>序言块</strong>，其含义可以类比于链表数据结构中的头指针，这一设计可以在之后的合并块拆分块时省去对边界情况的考虑，大大降低了讨论的难度。</p><h4 id="重点代码解读"><a href="#重点代码解读" class="headerlink" title="重点代码解读"></a>重点代码解读</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> WSIZE 4 <span class="hljs-comment">/* Word and header/footer size (bytes) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DSIZE 8 <span class="hljs-comment">/* Double word size (bytes) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ALIGNMENT 16 <span class="hljs-comment">/* 16 bytes alignment */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MINBLOCKSIZE 16 <span class="hljs-comment">/* Min size of block(bytes) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHUNKSIZE (1 &lt;&lt; 12) <span class="hljs-comment">/* Extend heap by this amount (bytes) */</span></span><br></code></pre></td></tr></table></figure><p>大部分函数都可以完全照搬csapp中的实现方法，其中<code>find_fit</code>和<code>place</code>两个自定义函数实现思路如下：</p><ul><li><code>static void* find_fit(size_t size)</code>：采用首次适配搜索方法，从头线性扫描链表，找到首个未分配且容量为空的块。</li><li><code>static void place(void* bp, size_t asize)</code>：从给定的未分配块中“挖去”<code>asize</code>大小的一部分分配，剩余部分如果满足大于最小块大小（16 bytes），则将其分割成新的块。</li></ul><h4 id="测试结果及分析"><a href="#测试结果及分析" class="headerlink" title="测试结果及分析"></a>测试结果及分析</h4><p><img src="/img/ICS\image-20230113165525883.png" alt="" style="zoom: 50%;" /></p><p>整体表现平平，在不涉及重分配的情况下空间利用率尚可，但吞吐率偏低。对此结果的分析如下：</p><ul><li>吞吐率偏低：隐式空闲链表上存有所有已分配和未分配的块，这样做的好处是数据结构简单内部碎片化少，但也会导致每次搜索时时间复杂度正比于块的个数，在块总数较多的情况下会显著增加时间开销，因而导致吞吐率降低。</li><li>涉及重分配操作的部分表现不佳：V1版本实现时采取的是最简单的realloc逻辑，即不管如何都删去原有的块并为之分配新的块，这样做也会增加不必要的时间开销和外部碎皮化的风险，导致吞吐率和空间复杂度双双下降。</li><li>某些特殊测例导致：一些特殊测例制造的极端情况，下文提到时会进一步具体说明。</li></ul><p>基于以上分析，接下来在隐式空闲链表的基础上进一步改造优化</p><h3 id="V2-Segregated-Free-Lists-分离适配"><a href="#V2-Segregated-Free-Lists-分离适配" class="headerlink" title="V2 Segregated Free Lists 分离适配"></a>V2 Segregated Free Lists 分离适配</h3><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><p>这种数据结构的思想是在原有隐式空闲链表的基础上，在块之间再添加多路链表，将大小接近空闲块链接起来，从而实现更快查找。具体实现方法就是在每个块中，添加pred和succ指针，指向其对应类的前驱和后继。同时在起始地址处维护一个指针数组，用于指向各个类的第一个块。</p><p><img src="/img/ICS\image-20230113172852701.png" alt="" style="zoom: 50%;" /></p><p><img src="/img/ICS\image-20230113172700225.png" alt="" style="zoom: 50%;" /></p><p>按理说n应越大越好，但考虑到n过大可能会占用过多内存导致空间利用率低，经过实验，将n选取在21效果最好，即将所有空闲块分成$\{32\},\{33\sim64\}\cdots\{2049\sim4096\}\cdots\{2^{24}\sim\infty \}$共21类（由于加入了两指针，MINBLOCKSIZE为32，无需考虑小于32的空闲块）</p><h4 id="重点代码解读-1"><a href="#重点代码解读-1" class="headerlink" title="重点代码解读"></a>重点代码解读</h4><p>新增加<code>NEXT_BLKP</code>和<code>PREV_BLKP</code>宏，实现前驱后继的查找</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NEXT_BLKP(bp) ((char*)(bp) + GET_SIZE(((char*)(bp)-WSIZE)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PREV_BLKP(bp) ((char*)(bp)-GET_SIZE(((char*)(bp)-DSIZE)))</span><br></code></pre></td></tr></table></figure><p><code>insert</code>和<code>delete</code>函数，实现对空块的插入和删除，其操作和书中<code>coalesce</code>函数相似，本质上都是在链表中插入或者删除结点，对于删除操作，需要对于其前后的空块是否存在，分四种情况具体讨论。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * insert - insert block to the head</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">void</span>* bp)</span><br>&#123;<br><br>    <span class="hljs-comment">/* block size */</span><br>    <span class="hljs-type">size_t</span> size = GET_SIZE(HDRP(bp));<br>    <span class="hljs-comment">/* search the id */</span><br>    <span class="hljs-type">int</span> num = search(size);<br>    <span class="hljs-comment">/* if list is blank, put the block directly */</span><br>    <span class="hljs-keyword">if</span> (GET_HEAD(num) == <span class="hljs-literal">NULL</span>) &#123;<br>        PUT(block_list_start + WSIZE * num, bp); <span class="hljs-comment">/* head */</span><br>        PUT(bp, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">/* pred */</span><br>        PUT((<span class="hljs-type">size_t</span>*)bp + <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">/* succ */</span><br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* if list is not blank, put it after the head */</span><br>        PUT((<span class="hljs-type">size_t</span>*)bp + <span class="hljs-number">1</span>, GET_HEAD(num));<br>        PUT(GET_HEAD(num), bp);<br>        PUT(bp, <span class="hljs-literal">NULL</span>);<br>        PUT(block_list_start + WSIZE * num, bp);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * delete - delete the block</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* bp)</span><br>&#123;<br><br>    <span class="hljs-type">size_t</span> size = GET_SIZE(HDRP(bp));<br>    <span class="hljs-type">int</span> num = search(size);<br>    <span class="hljs-keyword">if</span> (GET_PRE(bp) == <span class="hljs-literal">NULL</span> &amp;&amp; GET_SUC(bp) == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">/* Case 1 only one block: succ and pred both null */</span><br>        PUT(block_list_start + WSIZE * num, <span class="hljs-literal">NULL</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (GET_PRE(bp) != <span class="hljs-literal">NULL</span> &amp;&amp; GET_SUC(bp) == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">/* Case 2 tail block*/</span><br>        PUT(GET_PRE(bp) + <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (GET_SUC(bp) != <span class="hljs-literal">NULL</span> &amp;&amp; GET_PRE(bp) == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">/* Case 3 head block*/</span><br>        PUT(block_list_start + WSIZE * num, GET_SUC(bp));<br>        PUT(GET_SUC(bp), <span class="hljs-literal">NULL</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (GET_SUC(bp) != <span class="hljs-literal">NULL</span> &amp;&amp; GET_PRE(bp) != <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">/*Case 4 common block: both succ and pred exist*/</span><br>        PUT(GET_PRE(bp) + <span class="hljs-number">1</span>, GET_SUC(bp));<br>        PUT(GET_SUC(bp), GET_PRE(bp));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当调用<code>coalesce</code>和<code>place</code>时，也对块进行了合并以及切分的操作，因此，也需要在相应位置调用<code>delete</code>和<code>insert</code>来维护分离链表，其时间开销也都是$O(1)$的。</p><p>基于分离适配方法，重新设计<code>find_fit</code>函数，每次现根据size大小找到其落在的区间，对该链表进行线性扫描，如果并没有找到合适的空快，则转向更大的区间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * find_fit - begin from the smallest class acording to size, find the fit block</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-title function_">find_fit</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num = search(size); num &lt; CLASS_SIZE; num++) &#123;<br>        <span class="hljs-comment">/* scan one list, if no suitable block, jump to bigger list*/</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span>* bp = GET_HEAD(num); bp; bp = GET_SUC(bp)) &#123;<br>            <span class="hljs-keyword">if</span> (GET_SIZE(HDRP(bp)) &gt;= size) &#123;<br>                <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)bp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，在debug过程中课本基于32位机器所写的代码所制造的隐患渐渐显现，我采取的办法较为简单暴力，将所有原书中<code>unsigned int</code>改为<code>size_t</code>（定义为<code>unsigned long</code>），并将DSIZE和WSIZE扩大为两倍，这样做虽然可能制造额外的空间开销，但是可以较好复用原书代码，并且经过和其它同学对比，这种操作对结果的影响并不大。</p><h4 id="测试结果及分析-1"><a href="#测试结果及分析-1" class="headerlink" title="测试结果及分析"></a>测试结果及分析</h4><p><img src="/img/ICS\image-20230113182616136.png" alt="" style="zoom: 50%;" /></p><p>分离适配方法将多个测例的Kops提升了好几个数量级，吞吐率终于可以看了。熬夜DEBUG至此，不禁令人精神为之一振！下面就要对具体的测例做进一步优化。</p><h3 id="V3-针对测例优化调整"><a href="#V3-针对测例优化调整" class="headerlink" title="V3 针对测例优化调整"></a>V3 针对测例优化调整</h3><h4 id="提高初块利用率"><a href="#提高初块利用率" class="headerlink" title="提高初块利用率"></a>提高初块利用率</h4><p>课本提供的<code>mm_inti</code>函数要求先为其分配一段固定大小为CHUNKSIZE(4KB)的空块，而细心观察会发现测例<code>coalescing-bal.rep</code>的特点是反复分配和释放一段内存，而内存经过16字节补齐后又刚好大于初块的大小，这就导致每次程序都会认为现有的空块无法满足要求，在尾部拓展要求大小的空间，这就导致初块始终无法被用上。基于此，我们对mm_inti做如下修改，减小初始分配块的大小，从而提高空间利用率。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (extend_heap(<span class="hljs-number">2</span> * DSIZE / WSIZE) == <span class="hljs-literal">NULL</span>) <span class="hljs-comment">/* adjust for coalescing-bal.rep */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br></code></pre></td></tr></table></figure><h4 id="realloc-优化"><a href="#realloc-优化" class="headerlink" title="realloc 优化"></a>realloc 优化</h4><p>正如对V1版本测试结果所分析的那样，无脑free和malloc的方法会带来大量无必要的时间开销。事实上，当新的空间大于旧的空间且待转移的那部分块前后相邻部分又恰好空闲时，其实存在利用现有块儿就地分配更大的内存的可能，具体表现为<strong>空闲块融合</strong>和<strong>尾部堆扩展</strong>两种方法。</p><ul><li>空闲块融合：重分配时，如果后方有空闲块可以进行融合，再看空间够不够，如果够了就不用释放再分配了，直接就地分配新内存块</li><li>尾部堆扩展：如果要重新分配的块是尾部块，则只需要扩展新旧块相差的大小，就可以直接将尾部块转化成新块。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* <span class="hljs-title function_">mm_realloc</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-comment">/* if ptr = NULL ,just mm_malloc(size) */</span><br>    <span class="hljs-keyword">if</span> (!ptr)<br>        <span class="hljs-keyword">return</span> mm_malloc(size);<br>    <span class="hljs-comment">/* if size = 0 ,just mm_free(ptr) */</span><br>    <span class="hljs-keyword">if</span> (!size) &#123;<br>        mm_free(ptr);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-type">size_t</span> asize = ALIGN(size + DSIZE);<br>    <span class="hljs-type">size_t</span> copysize = GET_SIZE(HDRP(ptr));<br>    <span class="hljs-type">char</span>* newptr;<br>    <span class="hljs-comment">/* if copysize = asize, don&#x27;t need to move */</span><br>    <span class="hljs-keyword">if</span> (copysize == asize)<br>        <span class="hljs-keyword">return</span> ptr;<br>    <span class="hljs-type">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(ptr)));<br>    <span class="hljs-type">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(ptr)));<br>    <span class="hljs-type">char</span>* next_bp = NEXT_BLKP(ptr);<br>    <span class="hljs-type">size_t</span> next_size = GET_SIZE(HDRP(next_bp));<br><br>    <span class="hljs-keyword">if</span> (prev_alloc &amp;&amp; !next_alloc &amp;&amp; (copysize + next_size &gt;= asize)) &#123; <span class="hljs-comment">/* next block is blank and total size big enough */</span><br>        delete (next_bp);<br>        allocate(ptr, copysize + next_size, <span class="hljs-number">1</span>);<br>        place(ptr, copysize + next_size);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!next_size &amp;&amp; asize &gt;= copysize) &#123; <span class="hljs-comment">/* the block is at the end, just extend it to asize */</span><br>        <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>)(mem_sbrk(asize - copysize)) == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        allocate(ptr, asize, <span class="hljs-number">1</span>);<br>        allocate(NEXT_BLKP(ptr), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        place(ptr, asize);<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* final way, mm_malloc */</span><br>        newptr = mm_malloc(asize);<br>        <span class="hljs-keyword">if</span> (newptr == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        memmove(newptr, ptr, MIN(copysize, size));<br>        mm_free(ptr);<br>        <span class="hljs-keyword">return</span> newptr;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ptr;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="place-优化"><a href="#place-优化" class="headerlink" title="place 优化"></a>place 优化</h4><p>在realloc优化的基础上，我们不由得进一步思考，能否在分配时尽量多的让较大的块放在后面，从而使其重分配时能够更有可能触发realloc优化机制，从而提高吞吐率。此外，在分配块时，能否通过规划好不同大小块的位置，从而减小内部碎片。这两个问题都指向了对place函数的优化。</p><p>我们规定，如果当前适配的块大小比需要分配的大很多（大于MINBLOCKSIZE）时，我们将空间较大的块分配在空闲块的后部，较小的块分配在前部，并为之设定一个阈值SMALLSIZE（最后选为128 bytes）这样的组织方式有两方面好处，一是对块的大小进行了粗分类，有利于之后合并，另外针对<code>binary2-bal.rep</code>，这样做大大提高了尾部堆扩展的触发次数，从而进一步提高吞吐率。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-title function_">place</span><span class="hljs-params">(<span class="hljs-type">void</span>* bp, <span class="hljs-type">size_t</span> asize)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> size = GET_SIZE(HDRP(bp));<br>    <span class="hljs-type">size_t</span> rsize = size - asize;<br>    <span class="hljs-keyword">if</span> (!GET_ALLOC(HDRP(bp))) <span class="hljs-comment">/* for realloc, if bp is not blank, don&#x27;t delete it */</span><br>        delete (bp);<br>    <span class="hljs-keyword">if</span> (rsize &gt;= MINBLOCKSIZE) &#123; <span class="hljs-comment">// split block</span><br>        <span class="hljs-keyword">if</span> (asize &gt;= SMALLSIZE) &#123; <span class="hljs-comment">/* if asize &gt;= SMALLSIZE, then allocat it at the back of the block*/</span><br>            allocate(bp, rsize, <span class="hljs-number">0</span>);<br>            allocate(NEXT_BLKP(bp), asize, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> NEXT_BLKP(bp);<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* if asize &lt; SMALLSIZE, then allocat it at the front of the block */</span><br>            allocate(bp, asize, <span class="hljs-number">1</span>);<br>            allocate(NEXT_BLKP(bp), rsize, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> bp;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-comment">// do not split</span><br>    &#123;<br>        allocate(bp, size, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> bp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过上述优化后，最终得分</p><p><img src="/img/ICS\image-20230113191932522.png" alt="" style="zoom: 50%;" /></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>从几次优化的测试结果来看，分离空闲链表对性能的提升最为明显，以极小的空间利用率代价取得了吞吐率的巨大提升，几乎让得分翻了一倍！不过这也并非意味着隐式空闲链表再无用武之地，课本中指出，当总体块个数比较确定且并不是很多的情况下，隐式空闲链表可以减小内部碎片化程度并提高空间利用效率。</p><p>此外，适当调整常数对于提升程序性能也可能有一定的帮助，如在实验过程中，发现CHUNKSIZE设为$2^{13}$性能会更好，但因为自身能力原因，还无法给出合理的解释。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次实验对我个人的编程能力也是一次极大的挑战，引用一篇博客的话，可以作为我完成作业时的内心写照。</p><blockquote><p>这个实验写得人头皮发麻，欲罢不能。定义一堆宏，指针满天飞，写时一时爽，debug 火葬场。我整个周末几乎都在与 segmentation fault 打交道，随意一个小笔误就要找几个小时，唉。</p></blockquote><p>经过这次实验的洗礼，我对指针和地址的理解都更深了一层，对于malloc的内部原理也有了进一步的理解，收获颇丰，感谢助教和老师们的辛苦付出，春节快乐！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zero4drift.github.io/posts/csapp-malloclab-jie-ti-si-lu-ji-lu/#针对-coalesce-trace-文件优化定制">CSAPP-malloclab 解题思路记录 - 找一个吃麦旋风的理由 (zero4drift.github.io)</a></p><p><a href="https://zhuanlan.zhihu.com/p/459355154#:~:text=malloc lab的一些奇技淫巧 1 1.针对某trace的优化 2,2.查找空闲块的奇技淫巧 3 3.省略脚部的优化 4 4.realloc的优化">malloc lab的一些奇技淫巧 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/338556253">与 Malloc Lab(in csapp) 大战三天三夜纪实 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/496366818">CSAPP-Lab08 Malloc Lab 深入解析 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/150100073">CSAPP:Lab5-Malloc Lab - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/374478609">高性能 Malloc Lab —— 不上树 97/100 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ICS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ICS Coroutine Lab Report</title>
    <link href="/2023/01/16/ICS-Coroutine-Lab-Report/"/>
    <url>/2023/01/16/ICS-Coroutine-Lab-Report/</url>
    
    <content type="html"><![CDATA[<h1 id="REPORT"><a href="#REPORT" class="headerlink" title="REPORT"></a>REPORT</h1><h2 id="Task-1"><a href="#Task-1" class="headerlink" title="Task 1"></a>Task 1</h2><h4 id="代码补全"><a href="#代码补全" class="headerlink" title="代码补全"></a>代码补全</h4><p><strong>serial_execute_all</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">serial_execute_all</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        is_parallel = <span class="hljs-literal">false</span>;<br>        g_pool = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-type">bool</span> all_finished = <span class="hljs-number">0</span>;  <span class="hljs-comment">//标记是否都结束</span><br>        <span class="hljs-keyword">while</span> (!all_finished) &#123;<span class="hljs-comment">//只要存在没有结束的协程，就不断循环</span><br>            all_finished = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coroutines.<span class="hljs-built_in">size</span>(); i++) &#123;   <span class="hljs-comment">//轮询所有状态</span><br>                <span class="hljs-keyword">if</span> (!coroutines[i]-&gt;finished) &#123;<span class="hljs-comment">//发现没有结束的协程</span><br>                    all_finished = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">if</span>(!coroutines[i]-&gt;ready)&#123;<span class="hljs-comment">//Task 2内容</span><br>                        coroutines[i]-&gt;ready = coroutines[i]-&gt;<span class="hljs-built_in">ready_func</span>();<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (coroutines[i]-&gt;ready == <span class="hljs-literal">true</span>) &#123;<br>                        context_id = i; <span class="hljs-comment">//更新正在执行的协程id</span><br>                        coroutines[i]-&gt;<span class="hljs-built_in">resume</span>();    <span class="hljs-comment">//切入这个协程</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> context : coroutines) &#123;<span class="hljs-comment">//所有协程都执行完后删除所有context</span><br>            <span class="hljs-keyword">delete</span> context;<br>        &#125;<br>        coroutines.<span class="hljs-built_in">clear</span>();<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>“context.s”</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs asm">.global coroutine_entry<br>coroutine_entry:<br>    movq %r13, %rdi<br>    callq *%r12<br><br>.global coroutine_switch<br>coroutine_switch:<br>    # TODO: Task 1<br>    # 保存 callee-saved 寄存器到 %rdi 指向的上下文<br>    # 保存的上下文中 rip 指向 ret 指令的地址（.coroutine_ret）<br>    leaq .coroutine_ret(%rip), %rax<br>    movq %rax, 120(%rdi)<br>    movq %rsp, 64(%rdi)<br>    movq %rbx, 72(%rdi)<br>    movq %rbp, 80(%rdi)<br>    movq %r12, 88(%rdi)<br>    movq %r13, 96(%rdi)<br>    movq %r14, 104(%rdi)<br>    movq %r15, 112(%rdi)<br><br>    # 从 %rsi 指向的上下文恢复 callee-saved 寄存器<br>    movq  64(%rsi), %rsp    <br>    movq  72(%rsi), %rbx<br>    movq  80(%rsi), %rbp    <br>    movq  88(%rsi), %r12    <br>    movq  96(%rsi), %r13    <br>    movq  104(%rsi), %r14<br>    movq  112(%rsi), %r15<br>    # 最后 jmpq 到上下文保存的 rip<br>    jmpq *120(%rsi)<br><br>.coroutine_ret:<br>    ret<br></code></pre></td></tr></table></figure><p><strong>resume与yield</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">yield</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!g_pool-&gt;is_parallel) &#123;<br>        <span class="hljs-comment">// 从 g_pool 中获取当前协程状态</span><br>        <span class="hljs-keyword">auto</span> context = g_pool-&gt;coroutines[g_pool-&gt;context_id];<br>        <span class="hljs-comment">// 调用 coroutine_switch 切换到 coroutine_pool 上下文</span><br>        <span class="hljs-built_in">coroutine_switch</span>(context-&gt;callee_registers, context-&gt;caller_registers);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">resume</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">coroutine_switch</span>(caller_registers,callee_registers);<br>    <span class="hljs-comment">// 调用 coroutine_switch</span><br>    <span class="hljs-comment">// 在汇编中保存 callee-saved 寄存器，设置协程函数栈帧，然后将 rip 恢复到协程 yield 之后所需要执行的指令地址。</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="协程切入-amp-切出时函数栈变化"><a href="#协程切入-amp-切出时函数栈变化" class="headerlink" title="协程切入&amp;切出时函数栈变化"></a><strong>协程切入&amp;切出时函数栈变化</strong></h4><p>协程通过callee_registers寄存器的赋值来实现”系统栈“和”协程栈“之间的切换</p><p><img src="\img\ICS\image-20221115155304458.png" alt=""></p><p>具体到每个协程栈来说，每次<code>resume</code>切入一个协程时，<code>coroutine_switch</code>会做三件事：</p><ol><li>将调度器运行时的寄存器状态（这里寄存器状态仅限被调用者保存的八个寄存器，下同）存储到<code>caller_registers</code>中</li><li>从<code>callee_registers</code>取出上一次协程切出时保存的寄存器状态（第一次切入和非第一次切入<code>callee_registers</code>中RIP内容略有区别，上文对此有解释）赋给寄存器</li><li>将原来指向协程池栈顶的%rsp指向协程栈栈顶（其实这包含在2中，因为%rsp对栈的定位很重要所以特意强调一下）</li></ol><p><img src="\img\ICS\image-20221121170751522.png" alt=""></p><p>对于<code>yield</code>来说，<code>coroutine_switch</code>所做刚好相反：</p><ol><li>将协程运行时的寄存器状态保存到<code>callee_registers</code>中</li><li>从<code>caller_registers</code>取出上一次切入协程前，也是调度器（协程池）执行时的寄存器状态赋给寄存器</li><li>将原来指向协程栈顶的%rsp指回协程池栈栈顶，继续轮询</li></ol><p><img src="\img\ICS\image-20221121171145017.png" alt=""></p><h4 id="结合源代码，解释协程是如何开始执行的"><a href="#结合源代码，解释协程是如何开始执行的" class="headerlink" title="结合源代码，解释协程是如何开始执行的"></a>结合源代码，解释协程是如何开始执行的</h4><p><strong>“context.h”</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">basic_context</span>(<span class="hljs-type">uint64_t</span> stack_size)<br>      : <span class="hljs-built_in">finished</span>(<span class="hljs-literal">false</span>), <span class="hljs-built_in">ready</span>(<span class="hljs-literal">true</span>), <span class="hljs-built_in">stack_size</span>(stack_size) &#123;<br>    stack = <span class="hljs-keyword">new</span> <span class="hljs-type">uint64_t</span>[stack_size];<br>    <span class="hljs-comment">// 对齐到 16 字节边界</span><br>    <span class="hljs-type">uint64_t</span> rsp = (<span class="hljs-type">uint64_t</span>)&amp;stack[stack_size - <span class="hljs-number">1</span>];  <span class="hljs-comment">//在堆区开一个模拟栈的数组</span><br>    rsp = rsp - (rsp &amp; <span class="hljs-number">0xF</span>);  <span class="hljs-comment">//对齐十六字节边界</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">coroutine_main</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> basic_context * context)</span></span>;<br>    callee_registers[(<span class="hljs-type">int</span>)Registers::RSP] = rsp;<br>    <span class="hljs-comment">// 协程入口是 coroutine_entry</span><br>    callee_registers[(<span class="hljs-type">int</span>)Registers::RIP] = (<span class="hljs-type">uint64_t</span>)coroutine_entry;<br>    <span class="hljs-comment">// 设置 r12 寄存器为 coroutine_main 的地址</span><br>    callee_registers[(<span class="hljs-type">int</span>)Registers::R12] = (<span class="hljs-type">uint64_t</span>)coroutine_main;<br>    <span class="hljs-comment">// 设置 r13 寄存器，用于 coroutine_main 的参数</span><br>    callee_registers[(<span class="hljs-type">int</span>)Registers::R13] = (<span class="hljs-type">uint64_t</span>)<span class="hljs-keyword">this</span>;<br>  &#125;<br><br></code></pre></td></tr></table></figure><p><strong>代码解释：</strong>程序运行一开始会调用<code>basic_context</code>的构造函数，构造函数中首先为这个context在堆区开了一个数组来模拟栈帧，同时将<code>callee_registers</code>数组的部分位置设定好初值，几个初值的作用如下：</p><p><strong>RSP：</strong>保存该协程的栈帧地址</p><p><strong>R13：</strong>保存此context指向自己的指针</p><p><strong>RIP：</strong>保存协程入口<code>coroutine_entry</code>函数地址，在这个函数里，会执行一步参数赋值操作(“context.s”第三行)，然后再去执行<code>coroutine_main</code> </p><p><strong>R12：</strong>保存<code>coroutine_main</code> 的地址，也就是<code>run()</code>函数所在的位置</p><p>第一次调用<code>resume()</code>函数（同样也是第一次执行此<code>context</code>的<code>coroutine_switch</code>函数），此时<code>callee_registers</code>中的RIP指向的是<code>coroutine_entry</code>函数地址，于是会首先跳到<code>coroutine_entry</code>的中，将%r13(此时存的是指向这个context的指针)赋值给%rdi（相当于给<code>coroutine_main</code>函数的参数赋值），再跳到%r12所保存的<code>coroutine_main</code>的函数地址，执行这个协程的<code>run</code>函数的代码。</p><pre><code class=" mermaid">graph LRA[rip] -- 指向入口函数 ---&gt; B[coroutine_entry]C[%r13] -- 传参给%rdi--&gt; BD[%r12] -- 将执行函数的地址传入 --&gt;BB --开始执行函数--&gt;E[coroutine_main]</code></pre><p>此后再执行<code>coroutine_switch</code>函数时，RIP都是重定向到第二个参数所保存的RIP值，对于<code>resume</code>来说，RIP从调度器代码段跳转到对应<code>context</code>的代码段，而对于<code>yield</code>来说则相反，RIP从<code>context</code>代码段跳转回调度器代码段。</p><p><strong>coroutine_main：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">coroutine_main</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> basic_context *context)</span> </span>&#123;<span class="hljs-comment">//第一次resume时进入</span><br>  context-&gt;<span class="hljs-built_in">run</span>();<span class="hljs-comment">//执行该协程（对本体来说时show函数）,如果协程未执行结束，则会在函数内yield</span><br>  context-&gt;finished = <span class="hljs-literal">true</span>;<span class="hljs-comment">//如果run函数顺利执行结束，则该协程已执行完成，此时修改执行标记</span><br>  <span class="hljs-built_in">coroutine_switch</span>(context-&gt;callee_registers, context-&gt;caller_registers);<span class="hljs-comment">//最后跳出协程，相当于最后一次yield</span><br>&#125;<br></code></pre></td></tr></table></figure><p>==coroutine_main内包含的其实就是整个函数从开始执行到最终结束的过程。==</p><h2 id="Task-2"><a href="#Task-2" class="headerlink" title="Task 2"></a>Task 2</h2><h4 id="代码补全-1"><a href="#代码补全-1" class="headerlink" title="代码补全"></a>代码补全</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">serial_execute_all</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        is_parallel = <span class="hljs-literal">false</span>;<br>        g_pool = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-type">bool</span> all_finished = <span class="hljs-number">0</span>;  <span class="hljs-comment">//标记是否都结束</span><br>        <span class="hljs-keyword">while</span> (!all_finished) &#123;<br>            all_finished = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coroutines.<span class="hljs-built_in">size</span>(); i++) &#123;   <span class="hljs-comment">//轮询所有状态</span><br>                <span class="hljs-keyword">if</span> (!coroutines[i]-&gt;finished) &#123;<span class="hljs-comment">//轮询到一个未完成的协程</span><br>                    all_finished = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">if</span>(!coroutines[i]-&gt;ready)&#123;<span class="hljs-comment">//如果该协程还没有“睡醒”，则需要判断一下它是否需要“睡醒”，即执行ready_func</span><br>                        coroutines[i]-&gt;ready = coroutines[i]-&gt;<span class="hljs-built_in">ready_func</span>();<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (coroutines[i]-&gt;ready == <span class="hljs-literal">true</span>) &#123;<span class="hljs-comment">//如果协程“睡醒”，则执行它</span><br>                        context_id = i; <span class="hljs-comment">//更新正在执行的协程id</span><br>                        coroutines[i]-&gt;<span class="hljs-built_in">resume</span>();    <span class="hljs-comment">//切入这个协程</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> ms)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (g_pool-&gt;is_parallel) &#123;  <span class="hljs-comment">//并行</span><br>        <span class="hljs-keyword">auto</span> cur = <span class="hljs-built_in">get_time</span>();<br>        <span class="hljs-keyword">while</span> (<br>            std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(<span class="hljs-built_in">get_time</span>() - cur)<br>                .<span class="hljs-built_in">count</span>()<br>            &lt; ms)<br>            ;<br>    &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">//顺序执行</span><br>        <span class="hljs-comment">// 从 g_pool 中获取当前协程状态</span><br>        <span class="hljs-keyword">auto</span> context = g_pool-&gt;coroutines[g_pool-&gt;context_id];<br>        <span class="hljs-comment">// 获取当前时间，更新 ready_func</span><br>        <span class="hljs-keyword">auto</span> cur = <span class="hljs-built_in">get_time</span>();<br>        context-&gt;ready = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// ready_func：检查当前时间，如果已经超时，则返回 true</span><br>        context-&gt;ready_func = [cur,ms]()&#123;<br>            <span class="hljs-built_in">return</span> (<br>            std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(<span class="hljs-built_in">get_time</span>() - cur)<br>                .<span class="hljs-built_in">count</span>()<br>            &gt;= ms);<br>        &#125;;<br>        <span class="hljs-comment">// 调用 coroutine_switch 切换到 coroutine_pool 上下文，此处通过yield函数实现</span><br>        <span class="hljs-built_in">yield</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="按照时间线，绘制出-sleep-sort-中不同协程的运行情况"><a href="#按照时间线，绘制出-sleep-sort-中不同协程的运行情况" class="headerlink" title="按照时间线，绘制出 sleep_sort 中不同协程的运行情况"></a>按照时间线，绘制出 <code>sleep_sort</code> 中不同协程的运行情况</h4><p><img src="\img\ICS\Task2.png" alt="Task2"></p><h4 id="目前的协程库实现方式是轮询-ready-func-是否等于-true，设计一下，能否有更加高效的方法"><a href="#目前的协程库实现方式是轮询-ready-func-是否等于-true，设计一下，能否有更加高效的方法" class="headerlink" title="目前的协程库实现方式是轮询 ready_func 是否等于 true，设计一下，能否有更加高效的方法"></a>目前的协程库实现方式是轮询 <code>ready_func</code> 是否等于 <code>true</code>，设计一下，能否有更加高效的方法</h4><p>可以尝试为每个协程设置优先级，对数值较小者，设置其协程优先级更高，而当此协程执行完后，通过适当的设置pass的值, 将其优先级设为最低或，这样，每次只要通过线性查找优先级最高者选择执行，即可起到和<code>sleep</code>函数相同的效果。</p><p>在此思想上进一步优化，可以通过维护一个类似于优先级队列的数据结构，来减小每次对线性扫描查找到优先级最高者而产生的时间开销，这样可以将每次查找的时间复杂度优化到均摊$O(logn)$。</p><h2 id="Task-3"><a href="#Task-3" class="headerlink" title="Task 3"></a>Task 3</h2><h4 id="代码补全-2"><a href="#代码补全-2" class="headerlink" title="代码补全"></a>代码补全</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> ((size / <span class="hljs-number">2</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-type">size_t</span> half = size / <span class="hljs-number">2</span>;<br>  <span class="hljs-type">size_t</span> probe = low + half;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Task 3</span><br>  <span class="hljs-comment">// 使用 __builtin_prefetch 预取容易产生缓存缺失的内存</span><br>  __builtin_prefetch(&amp;table[probe]);<br>  <span class="hljs-comment">// 并调用 yield</span><br>  <span class="hljs-built_in">yield</span>();<br>  <span class="hljs-type">uint32_t</span> v = table[probe];<br>  <span class="hljs-keyword">if</span> (v &lt;= value) &#123;<br>   low = probe;<br>  &#125;<br>  size -= half;<br> &#125;<br></code></pre></td></tr></table></figure><h4 id="汇报性能的提升效果"><a href="#汇报性能的提升效果" class="headerlink" title="汇报性能的提升效果"></a>汇报性能的提升效果</h4><p>此部分实验我借助了宋曦轩同学提供的测试脚本（脚本保存在<code>coroutinelab/coroutinelab/experiments.py</code>），测试loops在28，30，32下的优化效果（每种参数设定做10次实验取平均值），实验数据保存在<code>coroutinelab/coroutinelab/experiment_tiny_results.json</code>中。</p><p>根据实验数据绘制实验结果如下，其中纵坐标efficiency表示使用协程优化效率，计算公式为 <script type="math/tex">efficiency = \frac{coroutine \ access - naive \ access }{naive \ access}</script></p><p><img src="\img\ICS\experiment_tiny_eff_28.png" alt=""></p><p><img src="\img\ICS\experiment_tiny_eff_30.png" alt=""></p><p><img src="\img\ICS\experiment_tiny_eff_32.png" alt=""></p><p>数据可以观察得出以下结论：</p><ol><li>固定Log2_bytes，<strong>协程开的个数batch对二分查找的优化效率呈先增后减的趋势，极值点出现在batch为4~16</strong>，猜测batch较大时优化效率低的原因可能是创建和切换协程的时间成本要高于提前缓存节省的时间消耗，batch较小时优化效率低则可能是协程数量少优化效果不明显，而创建协程和切换本身又会造成时间消耗有关</li><li>对比不同的Log2_bytes，<strong>Log2_bytes越大整体优化效果越好</strong>，比如在Log2_bytes为28时几乎全部为负优化，而Log2_bytes为32时除了batch=1和barch=32时，二分查找的效率均得到了一定的提升，这可能是因为在数组较小时需要预取的缓存较少，导致优化不明显。</li></ol><p>除了上述结果，在获取实验数据时，注意到<strong>优化性能波动比较大</strong>，在一些特殊情况下，协程负优化相当明显，<strong>算法对输入较为敏感</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感谢助教提供的保姆级教程，实验的代码部分完成的相当顺利，但是花在REPORT上的时间则远远超出了自己的预期，其中的一个原因可能是REPORT完成断断续续，每次都得重新研究一遍才能回想起代码的逻辑来；另一个原因是花了太多的时间在各种作图上，通过这次作业找到了一些不错的绘图软件，希望之后的Lab不会在这些事上花太多的时间。</p><p>qwq下次一定要争取一口气写完REPORT（Flag必倒系列）</p>]]></content>
    
    
    
    <tags>
      
      <tag>ICS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ICS Attack Lab Report</title>
    <link href="/2023/01/16/ICS-Attack-Lab-Report/"/>
    <url>/2023/01/16/ICS-Attack-Lab-Report/</url>
    
    <content type="html"><![CDATA[<h1 id="Attack-Lab-Report"><a href="#Attack-Lab-Report" class="headerlink" title="Attack Lab Report"></a>Attack Lab Report</h1><h2 id="Part-I-Code-Injection-Attacks"><a href="#Part-I-Code-Injection-Attacks" class="headerlink" title="Part I: Code Injection Attacks"></a>Part I: Code Injection Attacks</h2><p>前三个任务的基本原理都是将我们写的代码注入到栈中的某个区域中，然后通过栈溢出的方式使函数ret后执行去调用我们所写的指令。</p><h3 id="Task1"><a href="#Task1" class="headerlink" title="Task1"></a>Task1</h3><p>通过<code>objdump -d</code>命令获得 <code>ctarget</code> 文件的汇编代码，任务一很简单只需要将touch1的函数入口地址放到test函数的返回地址即可让它执行这段代码，查看<code>ctartget</code>中<code>getbuf</code>函数栈帧空间为18个字节，因此注入字符如下，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">00 00 00 00 00 00 00 00#十八个字节的任意字符<br>00 00 00 00 00 00 00 00<br>00 00 00 00 00 00 00 00<br>f4 1c 40 00 00 00 00 00#touch1的地址，小端在前<br></code></pre></td></tr></table></figure><p>对应的栈帧构造如下</p><p><img src="/img/ICS/image-20221126133028927.png" style="zoom: 33%;" /></p><h3 id="Task2"><a href="#Task2" class="headerlink" title="Task2"></a>Task2</h3><p>这次不仅需要我们调用一个函数，还需要为该函数传参，设计思路为利用<code>getbuf</code>的栈帧空间注入为参数赋值并调用<code>touch2</code>的命令，然后让<code>test</code>栈帧的返回地址指向<code>getbuf</code>的栈顶，从而调用我们写好的代码，我们自己写的代码应该首先将cookie值传入rdi，再让rip指向<code>touch2</code>地址，可以通过<code>pushq</code>+<code>ret</code>的方式来实现。</p><p>我们将需要注入的代码通过<code>objdump -r -D</code>反汇编得到二进制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">0:   48 c7 c7 6c f2 03 5b    mov    $0x5b03f26c,%rdi<br>7:   68 28 1d 40 00          pushq  $0x401d28<br>c:   c3                      retq <br></code></pre></td></tr></table></figure><p>其中0x5b03f26c为cookie值，0x401d28为<code>touch2</code>的入口地址。</p><p>此外我们还需要知道<code>getbuf</code>栈顶地址的位置，这可以通过gdb调试设置断点得到，其地址为5565ed58</p><p>最终的注入字符如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">48 c7 c7 6c #mov    $0x5b03f26c,%rdi<br>f2 03 5b 68 #pushq  $0x401d28<br>28 1d 40 00 c3 00 00 00 #retq <br>00 00 00 00 00 00 00 00<br>58 ed 65 55 00 00 00 00#rsp地址<br></code></pre></td></tr></table></figure><p>对应栈帧构造如下：</p><p><img src="/img\ICS\image-20221126134409453.png" style="zoom: 33%;" /></p><h3 id="Task3"><a href="#Task3" class="headerlink" title="Task3"></a>Task3</h3><p>与前两个任务不同之处在于，本题在<code>touch3</code>函数内调了<code>hexmatch</code>函数，该函数会随机在其栈帧内压入数据<code>char *s = cbuf + random() % 100;</code>，这就会导致我们送入的字符串可能被覆盖，数据可能会丢失，因此我们需要把它存到一个更安全的地方——test函数的栈帧中，通过gdb调试，我们得到其栈顶地址为5565ed78，此外还需要将cookie值转为对应字符串的16进制Ascii码值，转换结果为35 62 30 33 66 32 36 63。因此我们总设计思路为：</p><ul><li>cookie转化为16进制</li><li>将字符串写到不会被覆盖的test栈空间，再将该地址送到%rdi中</li><li>将touch3首地址压栈再ret</li></ul><p>填入字符串如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">48 c7 c7 78 ed 65 55 68#movq    0x5565ed78, %rdi<br>4d 1e 40 00 c3 00 00 00#pushq   0x401e4d ret<br>00 00 00 00 00 00 00 00<br>58 ed 65 55 00 00 00 00#getbuf rsp<br>35 62 30 33 66 32 36 6300#cookie字符串形式16进制ascii值<br></code></pre></td></tr></table></figure><p>对应栈帧构造如下：</p><p><img src="/img\ICS\image-20221126141658981.png" style="zoom: 33%;" /></p><h2 id="Part-II-Return-Oriented-Programming"><a href="#Part-II-Return-Oriented-Programming" class="headerlink" title="Part II: Return-Oriented Programming"></a>Part II: Return-Oriented Programming</h2><p>根据writeup，接下来两个任务中由于设置栈随机化，我们不能像前面三个一样定位到精确地址插入代码。而为了实现攻击，我们需要从已经给定的代码中截取我们需要的代码序列，且这些序列以ret结尾。</p><h3 id="Task4"><a href="#Task4" class="headerlink" title="Task4"></a>Task4</h3><p>本题的<code>touch2</code>函数和Task2相同，要求都是要为调用函数并传入参数，汇编代码为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">popq %rax<br>movq %rax,%rdi<br></code></pre></td></tr></table></figure><p>用<code>objdump</code>反汇编<code>rtatget</code>文件后，找到这样两条代码段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">401f1e:8d 87 e1 40 58 c3    lea    -0x3ca7bf1f(%rdi),%eax<br>401f24:c3                   retq<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">401f34:b8 48 89 c7 90       mov    $0x90c78948,%eax<br>401f39:c3                   retq   <br></code></pre></td></tr></table></figure><p>其中<code>popq %rax</code>从401f22开始，<code>movq %rax,%rdi</code>从401f35开始，查找到touch2的入口地址后，最终注入的字符为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00<br>22 1f 40 00 00 00 00 00#popq %rax<br>6c f2 03 5b 00 00 00 00 #cookie<br>35 1f 40 00 00 00 00 00#movq %rax,%rdi<br>28 1d 40 00 00 00 00 00#touch2<br></code></pre></td></tr></table></figure><p>对应栈帧构造如下：</p><p><img src="/img\ICS\image-20221126171228580.png" style="zoom: 33%;" /></p><h3 id="Task5"><a href="#Task5" class="headerlink" title="Task5"></a>Task5</h3><p>本任务的<code>touch3</code>函数和Task3相同，区别在于不能用绝对地址的方式定位test函数的栈顶，需要用偏移量的方式寻址。我们最终写的代码最终实现这样的功能：</p><ul><li>把rsp里的栈指针地址放到rdi</li><li>拿到bias的值放到rsi</li><li>把栈指针地址和bias加起来放到rax，再传到rdi</li><li>调用<code>touch3</code></li></ul><p>对于加法，我们很幸运地从rtarget的反汇编文件中找到了这样一段代码，可以实现加法函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">401f5e:48 8d 04 37          lea    (%rdi,%rsi,1),%rax<br>401f62:c3                   retq <br></code></pre></td></tr></table></figure><p>其余对应的汇编代码也可以在文件中找到，最终输入的字符为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asm">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00<br>be 1f 40 00 00 00 00 00#movq %rsp,%rax<br>0b 1f 40 00 00 00 00 00#movq %rax,%rdi<br>22 1f 40 00 00 00 00 00#popq %rax<br>48 00 00 00 00 00 00 00#0x48<br>ea 1f 40 00 00 00 00 00#movl %eax %edx<br>94 1f 40 00 00 00 00 00#movl %edx %ecx<br>89 20 40 00 00 00 00 00#movl %ecx %esi<br>5e 1f 40 00 00 00 00 00#lea (%rdi,%rsi,1),%rax<br>0b 1f 40 00 00 00 00 00#movq %rax,%rdi<br>4d 1e 40 00 00 00 00 00#touch3<br>35 62 30 33 66 32 36 6300#cookie<br></code></pre></td></tr></table></figure><p>其中偏移量0x48是根据<code>movq %rsp,%rax</code>到<code>cookie</code>字符串首地址之间的指令条数确定的，每条指令占8字节，共9条指令</p><p>对应栈帧结构如下：</p><p><img src="/img\ICS\image-20221126174059768.png"  style="zoom: 33%;" /></p><h2 id="感想和收获"><a href="#感想和收获" class="headerlink" title="感想和收获"></a>感想和收获</h2><p>相比协程lab，个人感觉这次的lab无论是在任务量还是难度上都相对友好，这既归公于助教和老师细致的准备工作和贴心的答疑，也得益于网上搜集到的大量相关教程，在本次实验完成的过程中，我主要参考了<a href="https://zhuanlan.zhihu.com/p/60724948">CSAPP实验之attack lab - 知乎 (zhihu.com)</a>和<a href="https://zhuanlan.zhihu.com/p/566309516">实验三：Attack-Lab - 知乎 (zhihu.com)</a>这两篇文章。</p><p>在完成Task5时，我遇到了一定的困难，程序提示我输入了错误的指令，经过我的反复调试，发现最后问题出在某一条<code>movl</code>语句截取的时候没有关注后面跟着的字节使那条指令不在是我期待的<code>movl</code>含义，我后来找到了另一条更简单的语句来截取，成功解决了这个问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>ICS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DSA PA4 REPORT</title>
    <link href="/2023/01/16/DSA-PA4-REPORT/"/>
    <url>/2023/01/16/DSA-PA4-REPORT/</url>
    
    <content type="html"><![CDATA[<h1 id="CST-4-1-Report"><a href="#CST-4-1-Report" class="headerlink" title="CST 4-1 Report"></a>CST 4-1 Report</h1><h2 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h2><p>本题需要维护这样一个数据结构：对于$\forall i, i\in[0,n)$</p><ul><li>存有$[max(0,i-k-1),min(n-1,i+k+1)]$这一区间窗口内所有原件的信息</li><li>可以查询这一范围内和i异或值最大的字符串id</li><li>可以动态删去某个字符串和添加某个字符串到这个数据结构中</li></ul><p>基于此，我们最终选择<strong>字典树</strong>这一数据结构，下面对其进行详细介绍。</p><h4 id="字典树：规则"><a href="#字典树：规则" class="headerlink" title="字典树：规则"></a>字典树：规则</h4><p>对字典树的理解可以类比有限状态自动机（DFA），本题中字母表$\Sigma = \{0,1\}$，树的根节点相当于是自动机入口。从入口开始，每经过一个结点，01串将自己的第一个字符取出，如果是0则转向结点的左子树，是1则转向右子树，直到走到树的叶结点为止，每个叶结点可以视作自动机的一个终态</p><p>对于每个<strong>结点</strong>，用<code>cnt</code>存储路径经过这个结点的字符串数量</p><p>对于每个<strong>叶结点</strong>，还要记录这个终态对应的字符串的id值，由于可能存在多个id值的字符串相同的情况，这里的id值记录的是所有存在树中对应这一终态的字符串id最小值，$ _id = min(\{id | str[id] \land  id\in [max(0,i-k-1),min(n-1,i+k+1)]\}) $，这一操作是为了满足题目要求中“<strong>输出所有窗口内和id=i异或值最大的字符串id的最小值</strong>”要求。</p><h4 id="字典树：初始化"><a href="#字典树：初始化" class="headerlink" title="字典树：初始化"></a>字典树：初始化</h4><p>由于本题字母表中只有两个字母，所以字典树实际上是一棵高度等于64的二叉树。每个结点的左右子树分别代表接受0和1后转移到的状态。</p><h4 id="字典树：动态变化"><a href="#字典树：动态变化" class="headerlink" title="字典树：动态变化"></a>字典树：动态变化</h4><p>每当我们变换窗口时，字典树中都可能会插入一个字符串并删除一个字符串（当窗口移动到两端附近时，也可能出现不删除或不插入的情况）</p><h4 id="字典树：插入"><a href="#字典树：插入" class="headerlink" title="字典树：插入"></a>字典树：插入</h4><p>考虑插入一个64位的01字符串<code>original[i]</code>。</p><p>从根节点开始，按照字典树转向规则深探，如果结点并没有对应的孩子，则创建它，同时我们将沿途经过的所有结点计数值加1，表示经过这一节点的字符串多了一个。</p><p>探到叶结点后，更新叶结点的id值，这要求我们插入的字符串一定是当前窗口中的最小值，<strong>因此，我们的窗口应该是从右往左移动，而非从左往右移动。</strong></p><h4 id="字典树：删除"><a href="#字典树：删除" class="headerlink" title="字典树：删除"></a>字典树：删除</h4><p>考虑删除一个64位的01字符串<code>original[i]</code>，这一字符串此前一定已经插入在树中。</p><p>从根节点开始，按照字典树转向规则深探，同时我们将沿途经过的所有结点计数值减1，表示经过这一节点的字符串少了一个。</p><h4 id="字典树：查询"><a href="#字典树：查询" class="headerlink" title="字典树：查询"></a>字典树：查询</h4><p>考虑查询j，使得$j\neq i \land j \in [max(0,i-k-1),min(n-1,i+k+1)]$且<code>original[j]</code>和<code>original[i]</code>异或值最大。异或值查询满足<strong>贪心条件</strong>，只需要每次都转向异或值最大的方向即可，具体来说就是如果有结点两个孩子的话，接收0后转向右子树，接收1后转向左子树，这样最终到达的终态得到一个id值即是所求结果。</p><p>一般来说，上述办法找到的id值和i是不同的，除非一种情况：<strong>i=0且窗口内所有字符串相同，此时找到的id为0</strong>，但根据题目要求，id值应该为1，这里需要特判一下。</p><h2 id="时间和空间复杂度的估算"><a href="#时间和空间复杂度的估算" class="headerlink" title="时间和空间复杂度的估算"></a>时间和空间复杂度的估算</h2><p><strong>时间复杂度：</strong>每个元件至多被插入一次、删除一次，对于每次插入、删除操作，时间复杂度均正比于树高$O(64)=O(1)$，而对n个元件，我们的时间复杂度为$O(n)$</p><p><strong>空间复杂度：</strong>考虑到每个字典树的结点都可能代表一个字符，字典树的总结点个数应该不大于$O(64n)$，其它的数组空间规模也符合$O(n)$，总的空间复杂度应是$O(n)$的。但这只是一个相当宽泛的上界，存在被卡常的可能。考虑到字典树靠近根节点的结点应该是可以复用的，下面对其进行更精细的分析：</p><p>考虑n的最大值$n=5\times10^5$，假设某一时刻窗口能够涵盖所有的字符串，n对2取对数后可以得到，前19层的树是满的，从第20层开始每个字符串对应一条单链，这样的结点数就达到了理论上的最大值，总个数为$2^{20}+5\times10^5\times(64-19)=23548576$。因此，理论上字典树占的空间为359.32MB（每个结点存4个int，空间大小为16byte）</p><p><code>bool original[500001][64]</code>数组存储了所有原件字符串信息，空间复杂度为$O(64n)=O(n)$，占空间大小为$64\times500001B=30.51MB$</p><p>因为窗口是从右往左移动的，还需要<code>int res[500001]</code>数组来存储结果，空间复杂度为$O(n)$，占空间大小为$4\times500001B=1.97MB$</p><p>总的占空间大小为$359.32+30.51+1.97=391.8MB&lt; 512MB$</p><h1 id="CST-4-2-Report"><a href="#CST-4-2-Report" class="headerlink" title="CST 4-2 Report"></a>CST 4-2 Report</h1><h2 id="算法构思-1"><a href="#算法构思-1" class="headerlink" title="算法构思"></a>算法构思</h2><p>本题所要完成的任务和Dijkstra算法相似，都是求从起点到终点的最短距离，不同之处在于权重由边转移到了点，但这并不会对算法本身造成过大的改动；另一个不同是本题要求还要求出最短路径的数量，这需要我们基于Dijkstra算法进行改进。此外，如果使用蛮力Dijkstra算法的话时间复杂度为$O(n^2)$代入n简单计算便可知会导致超时，因此我们需要设计一种数据结构，能够返回当前非永久性节点中路径长度最小的结点，避免$O(n)$的轮询，优先级二叉堆可以满足我们的这一需求。</p><h4 id="建图过程"><a href="#建图过程" class="headerlink" title="建图过程"></a>建图过程</h4><p>每个游戏关卡存储为一个<code>Node</code>结点，每个结构体中存有以下成员变量：</p><ul><li><code>minlen</code>：从起点开始，到结点的最短长度</li><li><code>num</code>：到结点的最短路径的数量</li><li><code>time</code>：通过结点所需的用时</li><li><code>flag</code>：标记结点是否为永久结点</li></ul><p>边的信息保存在<code>Edge e</code>数组中，本题中每条边都是一条无向边，我们将其转化为两条方向相反的边，这样便于建立以起始点为索引的链表，链表表头存储在数组<code>head</code>中。</p><h4 id="设计优先级二叉堆"><a href="#设计优先级二叉堆" class="headerlink" title="设计优先级二叉堆"></a>设计优先级二叉堆</h4><p>二叉堆中每一个结点<code>PQNode</code>存储两个变量：</p><ul><li><code>id</code>：记录这个点对应结点的id值</li><li><code>num</code>：记录<strong>在结点插入时</strong>，到达该结点的最短路径</li></ul><p>二叉堆堆顶的元素满足，堆顶的结点的<code>num</code>值为全堆最小。</p><p>每当插入一个<code>PQNode</code>结点时，我们将其添加在当前堆的末尾，然后根据其<code>num</code>值”上浮“。删除一个<code>PQNode</code>结点时，我们首先记录堆顶的值，然后将其和堆尾元素交换，随后让堆顶元素”下沉“。这些都是二叉堆的基本操作。</p><h4 id="Dijkstra算法：初始化"><a href="#Dijkstra算法：初始化" class="headerlink" title="Dijkstra算法：初始化"></a>Dijkstra算法：初始化</h4><p>一开始，将起点的最短路大小赋为该关卡的耗时，将其添加到堆中，并将起点设为工作结点</p><h4 id="Dijkstra算法：过程"><a href="#Dijkstra算法：过程" class="headerlink" title="Dijkstra算法：过程"></a>Dijkstra算法：过程</h4><p>每次确定一个工作结点后，将其变为永久结点，并更新所有和它相邻的非永久性结点的最短路径值和最短路径数量，对于工作结点p和其相邻结点q，更新规则如下：</p><ul><li>$minlen(p)+time(q)&gt;minlen(q)$，保持q的最短路径距离和最短路径数不变</li><li>$minlen(p)+time(q)=minlen(q)$，q的最短路径距离不变，最短路径数在原有基础上加上$num(q)$</li><li>$minlen(p)+time(q)&lt;minlen(q)$，q的最短路径距离更新为$minlen(p)+time(q)$，最短路径数更新为$num(q)$</li></ul><p>这样就实现了同时记录最短路径长度和最短路径数。</p><p>将所有相邻结点更新完后，从优先级二叉堆中不断取出堆顶元素p，直到取出的p表示的是一个现在为非永久节点为止，此时的p一定是所有非永久结点中最短路径距离最小的结点。将p确定新的工作结点，重复上述过程，直到终点变为永久结点为止。</p><h2 id="时间和空间复杂度的估算-1"><a href="#时间和空间复杂度的估算-1" class="headerlink" title="时间和空间复杂度的估算"></a>时间和空间复杂度的估算</h2><p><strong>时间复杂度：</strong>由于每条边至多只有一个方向上的结点会被插入到二叉堆中，所以二叉堆结点数至多为m，二叉堆的插入和删除操作时间复杂度均正比于其树高，也就是$O(log(m))$，由于每条无向边至多会插入一次，因此插入的总时间复杂度为$O(mlog(m))$，删除也是同理，每次取出的堆顶元素不一定就是我们需要的那个结点，可能某次寻找工作结点时需要多次取出堆顶元素，但取出的总元素个数不会大于堆中最大元素个数，因此取出操作的时间复杂度上界应该也是$O(mlog(m))$。因此，算法的时间复杂度为$O(mlog(m))$</p><p>除此以外，对结点和边的读入操作其复杂度为$O(n)$和$O(m)$，考虑题目并没有给出m和n的大小关系，但m和n具有相同的量级，因此总的时间复杂度也可以写作$O((m+n)log(m))$，这样写可以涵盖n很大但m很小的情况。</p><p><strong>空间复杂度：</strong>存储边的数组和二叉堆数组空间复杂度均为$O(m)$（这两个数组我都开到了2m的大小，实际上二叉堆数组大小开到m已经足够），存储邻接表表头的的数组和关卡结点数组的空间复杂度均为$O(n)$，因此，总的空间复杂度为$O(m+n)$</p><h1 id="CST-LAB3-BBST-Report"><a href="#CST-LAB3-BBST-Report" class="headerlink" title="CST LAB3 BBST Report"></a>CST LAB3 BBST Report</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>本题我选择实现的数据结构为Splay树和Avl树，下面对这两个数据结构的核心功能和公共接口进行说明。</p><h3 id="1-树结构实现"><a href="#1-树结构实现" class="headerlink" title="1. 树结构实现"></a>1. 树结构实现</h3><h4 id="1-1-二叉树结点-BinNode"><a href="#1-1-二叉树结点-BinNode" class="headerlink" title="1.1 二叉树结点 BinNode"></a>1.1 二叉树结点 <code>BinNode</code></h4><p>仿照课本的继承关系，Splay树和Avl树中的二叉树结点均用结构体<code>BinNode</code>实现，其中存储数据为：</p><ul><li>data：结点键值</li><li>parent，l，r：父节点和左右孩子结点的数组下标</li><li>height：结点高度（在Avl树中使用）</li><li>index：该结点对应的数组下标</li></ul><h4 id="1-2-旋转-zag-zig"><a href="#1-2-旋转-zag-zig" class="headerlink" title="1.2 旋转 zag,zig"></a>1.2 旋转 <code>zag</code>,<code>zig</code></h4><p>这同样是两种树可以通用的函数，函数参数为需要旋转的结点<code>v</code>下标<code>id</code>，<code>v</code>和其左右孩子构成了一个”旋转单元“，<code>zag</code>逆时针旋转，<code>zig</code>顺时针旋转。旋转重置父子之间指向关系（包括三个结点之间相互关系和他们与父亲或孩子结点之间的关系），并更新高度。</p><h4 id="1-3-伸展-Splay"><a href="#1-3-伸展-Splay" class="headerlink" title="1.3 伸展 Splay"></a>1.3 伸展 <code>Splay</code></h4><p><code>Splay</code>操作每次将最后访问的结点伸展至根，为了避免出现逐层旋转在一字型下可能会导致树高过高的问题，采用双层伸展的办法。当祖孙三代呈一字型时，先旋转祖父结点再旋转父亲结点；当祖孙三代呈之字型时，先旋转父亲结点再旋转祖父结点（其实也可以先祖父再父亲，主要为了和教材保持一致），旋转时，还需对父亲和祖父是否存在等情况做讨论，处理特殊情况。</p><h4 id="1-4-搜索-search"><a href="#1-4-搜索-search" class="headerlink" title="1.4 搜索 search"></a>1.4 搜索 <code>search</code></h4><p>基础搜索算法和普通二叉搜索树一致，都是从根节点开始深探直至找到对应节点或发生不存在孩子节点的情况，搜索过程中<code>_hot</code>始终指向查找结点的父节点。</p><p>Splay树要求对每一次查找操作都要将查找到的结点伸展至根，因此每次搜索后需要做一次判定：如果查找成功，则将命中结点伸展至根，否则将<code>_hot</code>结点伸展至根。</p><h4 id="1-5-插入-insert"><a href="#1-5-插入-insert" class="headerlink" title="1.5 插入 insert"></a>1.5 插入 <code>insert</code></h4><p>首先通过搜索函数<code>search</code>找到结点需要插入的位置，由于Splay树的搜索函数内置了伸展操作，所以执行完搜索后_hot结点就已伸展至根，此时根据插入节点和_hot结点的关系判断插入到其左孩子还是右孩子即可，Avl树无需伸展，但插入后需沿深探路径回溯至根，沿路检查结点是否处于平衡状态，如果遇到非平衡状态，则对该结点进行重平衡操作，教材给出的是3+4重构，这里并未对3+4重构进行封装，而是通过分情况讨论选择旋转方式zig/zag实现，当发现一个失衡结点并重平衡后，即可退出不再上溯。</p><h4 id="1-6-删除-remove"><a href="#1-6-删除-remove" class="headerlink" title="1.6 删除 remove"></a>1.6 删除 <code>remove</code></h4><p>首先还是搜索需要删除的结点并将其伸展至根，删除该结点后，取其后继<code>succ</code>为新的根节点，如果没有后继，则取其前驱<code>pred</code>。</p><p>对于Avl树，删除后需要沿路检查各父亲结点是否失衡并使其重平衡，而Splay树则不需要这样的操作。</p><h3 id="2-复杂度分析"><a href="#2-复杂度分析" class="headerlink" title="2. 复杂度分析"></a>2. 复杂度分析</h3><h4 id="2-1-Avl树"><a href="#2-1-Avl树" class="headerlink" title="2.1 Avl树"></a>2.1 Avl树</h4><p>根据讲义P540页的分析，考虑高为h的结点最少的Avl树，其结点个数满足递推式$S(h)=1+S(h-1)+S(h-2)$，因此，高度为h的AVL树，至少包含$S(h)=fib(h+3)-1$个结点，由于斐波那契数列通项公式为 $fib(n)=\frac{1}{\sqrt 5}[(\frac{1+\sqrt 5}{2})^n-(\frac{1-\sqrt 5}{2})^n]$，由于斐波那契数列大致呈指数增长，因此含n个结点的Avl树其最大树高也是$O(logn)$的，由于满二叉树，也就是最”胖“的Avl树高度也是$O(logn)$，所以这个界是严格的。</p><p>Avl树的搜索和普通二叉树是相同的，其算法复杂度均正比于树高$O(logn)$，而对于插入操作，在插入后只需要沿路回溯至非失衡结点重构，由于回溯深度不会超过深探的深度，也就是树高$O(logn)$，而重构操作本身又是$O(1)$的，因此插入算法时间复杂度也是$O(logn)$。删除操作和插入不同之处在于要一路回溯至根才停止，沿路重构所有失衡结点，而由于访问的结点个数和深探深度相同，因此最坏情况下也只需重构$O(logn)$次，因此删除操作的算法时间复杂度也是$O(logn)$。</p><p>综上，Avl树的搜索、插入、删除操作时间复杂度均为$O(logn)$，共m次操作，因此总的时间复杂度为$O(mlogn)$</p><h4 id="2-2-Splay树"><a href="#2-2-Splay树" class="headerlink" title="2.2 Splay树"></a>2.2 Splay树</h4><p>根据讲义，我们需要用势能分析的方法来分析其均摊复杂度。首先，我们定义Splay树中结点v的势能为$\phi(v)=log|v|$，$|v|$表示这个结点子树的结点个数，树的势能定义为$\Phi(T)=\Sigma_{v\in T}\phi(v)$，直觉告诉我们，越平衡的树，其势能越小，越倾侧的树，其势能越大，具体来说，单链的势能最大，为$log(n!)=O(nlogn)$。</p><p>给出势能的定义后，我们开始计算时间复杂度，首先，我们将问题简化，考虑单次将结点$x$旋转至根的时间复杂度，其他操作均可以视作这个操作的组合。而对于每次旋转至根的操作，可以分为两部分讨论：双旋和单旋。前者我们将用势能增量来表示复杂度，而后者由于单次旋转复杂度本身难以计算，但我们可以考虑经过m次旋转至根的操作后，单旋造成的时间复杂度本身应该不会不会超过树自身势能的bound，即$O(mlogn)$，我们只需要最后将其加上就可以，</p><p>下面我们重点分析单次双旋至根的时间复杂度，分为两种情况讨论：一字型和之字型</p><ul><li>一字型</li></ul><p>假设x,y,z分别为孩子，父亲，爷爷结点，旋转后对应的结点为x’,y’,z’。变化后的总势能为</p><script type="math/tex; mode=display">\begin{align} \Delta \Phi(T)&=\phi(x')+\phi(y')+\phi(z')-\phi(x)-\phi(y)-\phi(z)  \\&= \phi(y')+\phi(z')-\phi(x)-\phi(y)\end{align}</script><p>而复杂度应该为$O(1)+\Delta \Phi(T)$，下面我们尝试将其放缩为$k(\phi(x’)-\phi(x))，k为常数$的形式，由于常数k本身值是多少并不重要，所以我们可以将$O(1)$视作1来简化计算。我们可以先做这样的放缩：</p><script type="math/tex; mode=display">1+\Delta \Phi(T)\leq \phi(y')+\phi(z')-\phi(x)-\phi(y)\leq 1+ \phi(x')+\phi(z')-2\phi(x)</script><p>另一方面，根据一字型变化满足的条件，我们有：$|x’|=|z’|+|x|+1$，利用均值不等式我们可以进一步得到</p><script type="math/tex; mode=display">\phi(x)+\phi(z')-2\phi(x') = log\frac{|x||z'|}{|x'|^2}\le log\frac{|x'|^2}{4|x'|^2}=log\frac{1}{4}<-1</script><p>代入原式，可以解得</p><script type="math/tex; mode=display">\begin{align}1+\Delta \Phi(T) &\le 1+ \phi(x')+\phi(z')-2\phi(x)\\&<\phi(x')+\phi(z')-2\phi(x)-(\phi(x)+\phi(z')-2\phi(x'))\\&=3(\phi(x')-\phi(x))\end{align}</script><p>旋转结束后，总复杂度应小于$3(\phi(root)-\phi(x_0))&lt;3logn$</p><ul><li>之子型</li></ul><p>假设x,y,z分别为孩子，父亲，爷爷结点，旋转后对应的结点为x’,y’,z’。同样我们可以得到变化后的总势能为</p><script type="math/tex; mode=display">\begin{align} \Delta \Phi(T)&=\phi(x')+\phi(y')+\phi(z')-\phi(x)-\phi(y)-\phi(z)  \\&= \phi(y')+\phi(z')-\phi(x)-\phi(y)\end{align}</script><p>但我们不具备一字型的放缩条件，我们需要换一种方法放缩，具体的，我们有$|y’|+|z’|+1 = |x’|$，采用相似的放缩方法，不难得到</p><script type="math/tex; mode=display">\phi(y')+\phi(z')-2\phi(x')<-1</script><p>那么我们有：</p><script type="math/tex; mode=display">\begin{align}1 + \Delta  \Phi(T) &= 1+\phi(y')+\phi(z')-\phi(x)-\phi(y)\\&< 1+\phi(y')+\phi(z')-\phi(x)-\phi(y) - (\phi(y')+\phi(z')-2\phi(x'))\\&=2\phi(x')-\phi(x)-\phi(y)\\&<2(\phi(x')-\phi(x))\end{align}</script><p>旋转结束后，总复杂度应小于$2(\phi(root)-\phi(x_0))&lt;2logn$</p><p>综上，加上先前单旋的时间复杂度，n个节点的splay树做m次旋转至根操作的时间复杂度为$O((n+m)logn)$，而对于查找和删除操作，所做的无非就是找到其前驱或者后继并用$O(1)$的操作更新根节点，复杂度不会超过$O(n)$，因此，对于插入和删除操作来说，总时间复杂度与上述结果相同，因此，m次操作的时间复杂度为$O((n+m)logn)$</p><h2 id="效率测试"><a href="#效率测试" class="headerlink" title="效率测试"></a>效率测试</h2><h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><p>Windows x86-64操作系统，处理器为11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz   3.00 GHz</p><p>评测环境采用LemonLine 0.3.4，相比c语言的clock函数，评测系统的测试结果更准确</p><h3 id="测例设计"><a href="#测例设计" class="headerlink" title="测例设计"></a>测例设计</h3><p>我一共尝试设计了五类测例：</p><ol><li><code>rand_data</code>：假设用户会随机的进行增删差操作，且增删差的值也是完全随机的。每组测例的操作指令数量均为200000，生成程序为<code>rand_data.cpp</code>。</li><li><code>qd_data</code>：这里试图模拟的环境是，用户在插入随机大小的数据时会随机地查询当前树内的元素，并且每次查到对应的元素后都将其取出，插入和查询的概率相等。每组测例的操作指令数量均为200000，生成程序为<code>qd_data.cpp</code>。</li><li><code>queue_data</code>：这里试图模拟一种队列式的数据操作，即控制树内总结点个数<code>window_size</code>不变，每次向其中添加一个新的结点，并删除最早插入的结点。每组测例的操作指令数量为200000，<code>window_size</code>为2000，生成程序为<code>queue_data.cpp</code>。</li><li><code>readonly_data</code>：只读类数据，即随机进行插入和查询两种操作，不删除树中结点，每组测例的操作指令数量为100000。生成程序为<code>readonly_data.cpp</code>。</li><li><code>local_data</code>：设计这个环境主要是为了模拟Splay树的使用环境，用户会以10%的概率做插入操作，并以5%的概率做删除操作，否则做查询操作，且在删除和查询时，如果上一次访问的元素没有被删除，则优先对该元素执行查询/删除操作，如果该元素已经被删除，则随机取元素删除/查询。每组测例的操作指令数量为200000。生成程序为<code>local_data.cpp</code>。</li></ol><p>对于上述数据中的每一类，我都生成了五组程序，分析时对运行时间取平均，这样可以有效降低实验中IO操作以及测试环境不稳定产生的误差。</p><p>此外，对于local类型数据，为了探究不同数据规模下两树的性能的差异，我取n = 50000，100000，200000，300000，400000，500000下，分别对两棵树的性能进行测试。</p><p>此外，我还写了<code>std.cpp</code>用来对每组输入数据生成正确的答案，命名为<code>&lt;类型&gt;.out</code>。</p><p>运行脚本<code>datamaker.bat</code>可以实现一组测例的生成，所有测例生成程序保存在<code>/datamaker</code>目录下</p><h3 id="测例生成器"><a href="#测例生成器" class="headerlink" title="测例生成器"></a>测例生成器</h3><p>测例生成器的思路就是使用c++标准库中的set来记录当前树中的所有结点，需要插入一个随机数时，不断生成随机数并查询该随机数是否在set中，直到找到一个不存在于set中的随机数，将该随机数插入set中，并输出插入信息。输出删除或查询操作时，通过<code>advance(it, rand() % data.size())</code>的方法实现随机选取set中的某个元素查询或删除。</p><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><ul><li>五种不同类型的数据在两棵树下的运行时间：</li></ul><div class="table-container"><table><thead><tr><th>类型</th><th>local</th><th>qd</th><th>queue</th><th>rand</th><th>readonly</th></tr></thead><tbody><tr><td><strong>Avl</strong></td><td>0.1216 s</td><td>0.1340 s</td><td>0.1556 s</td><td>0.1434 s</td><td>0.0778 s</td></tr><tr><td><strong>Splay</strong></td><td>0.1184 s</td><td>0.1556 s</td><td>0.1996 s</td><td>0.1558 s</td><td>0.1186 s</td></tr></tbody></table></div><ul><li>不同规模的local类型数据在两棵树下的运行时间：</li></ul><div class="table-container"><table><thead><tr><th>n</th><th>50000</th><th>100000</th><th>200000</th><th>300000</th><th>400000</th><th>500000</th></tr></thead><tbody><tr><td><strong>Avl</strong></td><td>0.031 s</td><td>0.062 s</td><td>0.125 s</td><td>0.187 s</td><td>0.265 s</td><td>0.328 s</td></tr><tr><td><strong>Splay</strong></td><td>0.062 s</td><td>0.062 s</td><td>0.125 s</td><td>0.171 s</td><td>0.281 s</td><td>0.312 s</td></tr></tbody></table></div><p>具体结果保存在<code>/result</code>目录下</p><h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><h4 id="总体结论"><a href="#总体结论" class="headerlink" title="总体结论"></a>总体结论</h4><p>多数情况下，Splay树的性能都落后于Avl树，而在少数有优势的情况下，这种优势又微弱到几乎可以忽略不计。</p><h4 id="结论及分析"><a href="#结论及分析" class="headerlink" title="结论及分析"></a>结论及分析</h4><h5 id="Splay树付出的额外时间用于旋转"><a href="#Splay树付出的额外时间用于旋转" class="headerlink" title="Splay树付出的额外时间用于旋转"></a>Splay树付出的额外时间用于旋转</h5><p>Splay树的复原需要用到<code>splay</code>操作，伸展操作需要将最后访问的结点旋转至根，尽管Avl树在一些特殊情况下也会出现多次旋转至根的情况（删除操作），但和Splay树任何操作都需旋转至根相比，Avl树的旋转次数还是要远远小于Splay树，而对于删除操作不是很多的数据（比如<code>readonly</code>类型），Avl在旋转次数上的优势会更加明显，这也就解释了相比其它数据类型，为什么<code>readonly</code>类型下Avl性能会比Splay性能快很多。</p><p>为了具体说明Splay树和Avl树在旋转次数上的差异，我又做了进一步的实验，对于前面生成的local类型数据，记录以这些数据为输入时，两棵树的旋转次数（即<code>zig</code>/<code>zag</code>函数的调用次数）</p><div class="table-container"><table><thead><tr><th></th><th>Splay旋转次数</th><th>Splay时间消耗(s)</th><th>Avl旋转次数</th><th>Avl时间消耗(s)</th></tr></thead><tbody><tr><td><strong>1</strong></td><td>500108</td><td>0.140</td><td>14219</td><td>0.109</td></tr><tr><td><strong>2</strong></td><td>497590</td><td>0.125</td><td>14082</td><td>0.109</td></tr><tr><td><strong>3</strong></td><td>495890</td><td>0.14</td><td>14290</td><td>0.14</td></tr><tr><td><strong>4</strong></td><td>493757</td><td>0.078</td><td>14152</td><td>0.125</td></tr><tr><td><strong>5</strong></td><td>489016</td><td>0.109</td><td>14067</td><td>0.125</td></tr></tbody></table></div><p>实验结果显示旋转次数上，Splay树和Avl树存在数量级上的差异，而Splay树相比Avl树运行更快的几组数据，也恰恰是Splay旋转次数和Avl旋转次数之比较小的几组。</p><p>Splay树的思想是通过额外的旋转将最近访问的结点旋转至树根，从而让局部数据的访问和操作更加便利，而在除了local类型的数据中，由于没有局部性条件，所以Splay付出额外旋转的成本并没有带来预期的收益，导致其效率不如Avl树。而在我设计的local类型数据中，Splay确实通过付出额外的旋转成本获得了查询时的高效，但这种高效并不十分惊艳。</p><h5 id="数据规模增大并不会使Splay树效率提升"><a href="#数据规模增大并不会使Splay树效率提升" class="headerlink" title="数据规模增大并不会使Splay树效率提升"></a>数据规模增大并不会使Splay树效率提升</h5><p>通过观察不同规模的local类型数据在两棵树下的运行时可以发现一些有趣的现象：在数据规模较小（n=50000）时，Splay树落于下风，而随着n的增大，Splay树开始显现出一定的优势，但这种优势并不像我们预期的那样随着n的增大而增大，同时它还具有一定的不稳定性（ n=400000时Avl树更优），不过对于为什么会产生这样的现象，还给不出很好的解释。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Avl和Splay树作为两种常见的平衡树，在操作数远大于树结点个数的前提下，大O记号分析表明其均摊时间效率相同，但在具体实验表现中，Av的整体表现是略优于Splay树的。事实上，在尝试构造测例的过程中，的确可以通过构造一些具有极端局部性的数据来让Splay体现优势，这说明Splay树的优势只有在一些特殊情况下才能体现出来，而就总体而言，Avl树对数据的敏感度更低，性能也更优。</p>]]></content>
    
    
    
    <tags>
      
      <tag>DSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DSA PA3 REPORT</title>
    <link href="/2023/01/16/DSA-PA3-REPORT/"/>
    <url>/2023/01/16/DSA-PA3-REPORT/</url>
    
    <content type="html"><![CDATA[<h1 id="CST-3-2-Report"><a href="#CST-3-2-Report" class="headerlink" title="CST 3-2 Report"></a>CST 3-2 Report</h1><h2 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h2><p><strong>位图数据结构设计：</strong>本题最大的限制是6MB的空间，也就是只提供 $6\times2^{20}$ B大小的空间，而字符串长度要求需要能存$2^{24}$个数的空间，这就意味着不能用传统的int数组或bool的方式来存，于是自然想到了上课介绍的位图数据结构，这种数据结构将每个01字符存储在了一个bit里。这样成功将存储空间压缩到了$2^{21}$B的大小，从而满足题目对空间的要求。具体来说，是通过char数组的方式，以每个字符存储8个01字符的方式存储该字符串。</p><p>此外，在查询固定长度的子串时，由于一个字符某一固定长度的子串个数和这个字符长度几乎相同（准确来说只相差了一个子串长度），为了记住查询结果，我们同样需要一个规模和字符串大小相同的01字符串，而这个字符串的存储又可以通过一个位图实例来实现。</p><p>因此，该算法用到了两个位图实例，第一个位图实例<code>b</code>负责存储字符串，第二个位图<code>found</code>负责存储针对某一特定位数，符合这种长度的01串是否出现在字符串中，具体来说，第 i 位存储的是原字符串中是否存在 i 二进制形式下的子串。</p><p><strong>针对某一特定长度k，查找是否存在NotFound子串:</strong> 在之前的位图设计中已经说明了<code>found</code>实例的含义，接下来还需要特别说明的是如何更高效的实现在原串中检索所有子串。首先，注意到如果线性扫描子串的话，每次扫到的子串和前一个子串相比只要首尾两个字符不同，这就意味着不用每次都把子串转化为十进制数，而是可以通过首尾数字对上一个子串对应的十进制数进行适当的运算转换成下一个子串对应的十进制数。此外，线性扫描时，设置<code>num</code>变量来记录发现了多少个不同的子串，可以稍稍提高之后寻找最小字典序的子串的效率。</p><p><strong>通过二分查找来优化搜索效率：</strong>由于字符串长度限制在$2^{24}$范围内，这就意味着，NotFound子串长度不能超过24，也就是说我们最终找到的这个NotFound子串长度确定在$[1,24]$内，而我们需要找的是满足在原串中找不到该子串，且该子串在所有NotFound子串中长度和字典序最小，于是便可以通过二分查找的方式优化时间效率。</p><p>具体来说，算法针对特定子串长度k，通过函数<code>see(k)</code>来判断是否存在NotFound子串，并在<code>res</code>中保存该所有该长度且不存在在原字符串的子串中字典序最小的那个，如果返回值为<code>true</code>，即找到了较小子串，下一次查找的范围就在<code>[lo,k)</code>之间，否则就在$[mid+1,hi)$之间（$lo和hi初始为1和25$）</p><h2 id="时间和空间复杂度的估算"><a href="#时间和空间复杂度的估算" class="headerlink" title="时间和空间复杂度的估算"></a>时间和空间复杂度的估算</h2><p><strong>时间复杂度：</strong>根据上一节对算法的描述，位图的赋值和循秩访问都是$O(1)$时间的，因此字符串读入时间为$O(n)$。此外，针对特定一子串长度的查询，需要多次线性扫描，因此时间复杂度为$O(n)$而子串长度在$[1,logn]$之间，通过二分查找优化，需要查找$O(log(logn))$次，因此总查询时长的时间复杂度为$O(nlog(logn))$。</p><p>综上，总时间复杂度为$O(nlog(logn)) n=2^{24}$</p><p><strong>空间复杂度：</strong>每个位图实例都需要开一个char数组，其大小正比于字符串长度，相比一个char存一个字符来说现在一个char可以存8个字符，空间复杂度为$O(n/8)$，消去常数后是$O(n)$，除此以外程序没有其它的大开销，因此总的空间复杂度就是$O(n)$</p><h1 id="CST-3-4-2-Report"><a href="#CST-3-4-2-Report" class="headerlink" title="CST 3-4-2 Report"></a>CST 3-4-2 Report</h1><h2 id="算法构思-1"><a href="#算法构思-1" class="headerlink" title="算法构思"></a>算法构思</h2><h4 id="线段树动态创建结点"><a href="#线段树动态创建结点" class="headerlink" title="线段树动态创建结点"></a>线段树动态创建结点</h4><p>根据提示，本题考察的是线段树这一数据结构，但由于n数据范围较大（$n&lt;2^{31})$，将完整线段树建出来所需要的空间成本过高（完整建出整棵树的空间复杂度是$O(n)$）。而另一方面，查询/插入区间操作的次数m比较有限（$m&lt;2\times 10^{5}$），实际上并不会真正用到每一个节点，尤其是一些靠近树叶的节点的信息，因此我们需要使线段树创立结点动态化，即不是在一开始就将线段树完整的建出来，而是”随用随建“，只有当操作需要读取/改变某个节点的儿子节点的信息时才将其儿子节点建立，从而起到减少空间占用的效果。</p><p>具体来说，如讲义634页所展示，每次翻盘/查询操作所访问到的节点可以构成一棵二叉树，而这棵二叉树又只有$O(log(n))$个叶节点（一个线段被分成两半，左半部分每层至多一个右子树作为叶节点，右半部分同理），根据二叉树性质，二叉树的非叶节点数=叶节点数-1,所以整个二叉树的节点个数也是$O(log(n))$的，因此m次操作，至多会访问到$O(mlog(n))$个节点，并不会访问所以节点。最终，根据本题数据范围和空间限制，我选择将存储节点的数组开到$10^6$大小。</p><h4 id="函数设计"><a href="#函数设计" class="headerlink" title="函数设计"></a>函数设计</h4><p><strong>懒惰标记：</strong>对于每一个节点，我为其设计了懒惰标记：懒惰标记lazy的值表示该节点表示的区间内，除了sum记录的翻牌次数外，该节点下的每个节点还会被翻lazy次，这样当翻盘时遇到某一结点表示的区间完全包含于操作区间时，只需要为其懒惰标记加1即可，而不需要递归其子树</p><p><strong><code>push_down</code>: </strong> 当操作需要访问某个节点的子节点时，首先需要尝试为其创建子节点，然后再将懒惰标记下放，并将该节点的sum值更新。</p><p><strong><code>merge_up</code>: </strong>用于翻牌操作，但对某节点的子节点进行翻牌操作后，此时子节点的sum变为修改后的值，需要根据左右子节点的sum值更新父节点的sum，从而使父节点sum值记录修改后的结果</p><p><strong>翻牌：</strong>用递归函数的方式实现，针对某一结点，对其$[l,r]$子区间进行翻牌操作，会有四种情况：1.$[l,r]$恰好就是这个节点表示的区间，则修改其懒惰标记后返回。2.$[l,r]$仅包含于左子树，则递归其左子树。3.$[l,r]$仅包含于右子树，则递归右子树。4.$[l,r]$既包含于左子树，又包含于右子树。对于后三种情况，需要同时递归两棵子树，并在递归后将两侧结果<code>merge_up</code>赋给父节点。</p><p><strong>查询：</strong>设计思路和翻牌类似，不同在于查询相当于”只读“，并不会真正修改sum的大小（但依然会有懒惰标记下放的情况，比如所查询的区间设计了新节点的建立），所以在情况1中只需要返回其sum值，而情况4中不再需要<code>merge</code></p><h4 id="常数优化"><a href="#常数优化" class="headerlink" title="常数优化"></a>常数优化</h4><p>为了将节点数组开的尽量大，我尽可能缩小了每个节点的大小，最后每个Node类只有3个int和1个long long，这样就可以使存储节点的数组开到$10^6$大小。</p><h2 id="时间和空间复杂度的估算-1"><a href="#时间和空间复杂度的估算-1" class="headerlink" title="时间和空间复杂度的估算"></a>时间和空间复杂度的估算</h2><p><strong>时间复杂度：</strong>如前文”线段树动态创建结点“一节所述，每次翻牌/查询操作，至多访问到$O(log(n))$个节点，而对每个节点操作的时间复杂度为$O(1)$，共进行m次这样的操作，所以总的时间复杂度为$O(mlog(n))$</p><p><strong>空间复杂度：</strong>如前文”线段树动态创建结点“一节所述，只需要$O(mlog(n))$个节点就可以满足m次操作访问节点的需求。而每个节点的空间复杂度为$O(1)$，因此总的空间复杂度为$O(mlog(n))$（在程序中我开到了$10^6$）</p><h1 id="CST-3-5-Report"><a href="#CST-3-5-Report" class="headerlink" title="CST 3-5 Report"></a>CST 3-5 Report</h1><p>做完 CST 3-6 最近邻查找后，本以为手握KD树模板，这道题会完成得比较快，但事实证明不同的问题中kdtree差异还是很大的，为此花了不少时间来改进原树模板。</p><h2 id="算法构思-2"><a href="#算法构思-2" class="headerlink" title="算法构思"></a>算法构思</h2><h4 id="KD-Tree构造方法"><a href="#KD-Tree构造方法" class="headerlink" title="KD-Tree构造方法"></a>KD-Tree构造方法</h4><h5 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h5><p>KD-Tree每个结点存储以下信息：</p><p><code>l</code>,<code>r</code>：左右孩子下标</p><p><code>num[2]</code>：该结点所表示点的坐标</p><p><code>dim</code>：该结点所“切”的维度，$dim\in[0,d)$</p><p><code>up_bond[2],low_bond[2]</code>：每一个结点都代表在2维空间的矩形中“切”了一刀，这两个数组表示的就是这个矩形的上下界。对于每一个结点点，我们规定其上下界为这个结点表示区域包含的所有结点的上下确界，特别的，如果只有一个结点，那么其上下确界就是自己的坐标。</p><p><code>max_temp,min_temp</code>:该结点表示区域内的最高气温和最低气温。</p><h5 id="建立KD-Tree"><a href="#建立KD-Tree" class="headerlink" title="建立KD-Tree"></a>建立KD-Tree</h5><p>原始结点被输入后存储在数组<code>node</code>中，我们用函数<code>build(lp,rp,d0)</code>递归地建立KD-Tree，对每一个递归实例：</p><ol><li>将<code>node</code>数组中下标处于$[lp,rp]$之间的部分进行升序排序，排序依据是其第d0维的坐标大小($d0=0 , 1$)</li><li>对区间进行线性扫描，确定空间坐标的上下确界，更新<code>up_bond[2],low_bond[2]</code></li><li>找到排序后区间内中位数的结点，用该结点的坐标来构造一个KD-Tree中的结点，并将该结点保存在<code>kdtree[index]</code>中</li><li>递归$[lp,rp]$的左半部分和右半部分（构造时需要判定左右区间是否为空，如果为空则不需要再为其建立子结点，此时其子结点下标指向0，也可视作空结点或垃圾结点），递归构造<code>kdtree[index]</code>的左右子树，最后更新其区域内温度最大值和最小值。</li></ol><p><strong>区间内的温度最值查找：</strong></p><p>我们设计了<code>query_p</code>函数来递归地查找结点p表示的区域和给定查找区间的交集，并更新查找到的气温最大值和最小值，对于每个结点分为以下四种情况讨论：</p><ol><li>到达空结点，则直接返回，不做更新操作</li><li>结点表示区域包含于查找区间，则直接根据这个结点标记的气温最大值和最小值更新查找结果，不需要再深探</li><li>结点表示区域与查找区间完全无交集，则直接返回不做更新操作</li><li>结点表示区域与查找区域存在交集，则首先根据这个结点表示站点的温度最大值和最小值更新查找结果，然后对其左右子树进行深探。</li></ol><p>在实际写代码的时候，我们采取比较两个维度来确定查找区间和结点区间的关系，这是和讲义中KD树区间查询不同的地方，但显然这个剪枝要比比较单维度更强，实际运行的时候效果也更好。</p><h2 id="时间和空间复杂度的估算-2"><a href="#时间和空间复杂度的估算-2" class="headerlink" title="时间和空间复杂度的估算"></a>时间和空间复杂度的估算</h2><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>本题的时间消耗来自两步操作：建立KD-Tree和对KD-Tree的查找，下面分别对其进行分析。</p><p>建立KD-Tree的时间复杂度可以这样分析：考虑一颗满树，其深度为k的层有$2^k$个结点，也就对应在递归建立是要创建$2^k$个递归实例，对于每一个递归实例，其包含的区间长度为$len \leq \frac {n}{2^{k}}$，每一个递归实例中，时间复杂度主要来自区间排序，其复杂度为$O(lenlog(len))$而每一层总的时间复杂度应为$O(lenlog(len) \cdot 2^k) = O(n(logn-k)) k=1,2,… logn$。KD-Tree共有$logn$层，因此总的时间复杂度为$O(n(logn)^2)$。</p><p>对KD-Tree的每次区间查找，根据讲义中对KD树查询的时间复杂度分析，由于每两刀最多切到2个矩形，因此复杂度递推式满足$Q(n)=2Q(n/4)+O(1)$，因此其复杂度为$O(\sqrt n)$（讲义中的问题是记录具体的所有点，因此还要加上report的复杂度r，但本题只获取区间最值，更新次数应正比于区间包含的矩形框个数，对于完全包含于区间的矩形框，不需要深究其内部的每个点，因而不需要加r）。</p><p>综上，结合这两步操作，总的时间复杂度为$O(n(logn)^2+m\sqrt n)$</p><h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><p>KD-Tree存储在数组<code>kdtree</code>中，每个结点的struct需要存储12个int，数组空间消耗为$O(n)$，原始结点存储在二维<code>node</code>数组中，其大小也为$O(n)$，建树的递归实例个数应等于KD树的结点个数，节点个数不大于2n，递归建树空间复杂度为$O(n)$，查询递归的递归实例个数应等于访问结点的个数$O(log(n))$。</p><p>因此，总的空间复杂度为$O(n+log(n)) = O(n)$</p><h1 id="CST-3-6-Report"><a href="#CST-3-6-Report" class="headerlink" title="CST 3-6 Report"></a>CST 3-6 Report</h1><h2 id="算法构思-3"><a href="#算法构思-3" class="headerlink" title="算法构思"></a>算法构思</h2><h4 id="KD-Tree构造方法-1"><a href="#KD-Tree构造方法-1" class="headerlink" title="KD-Tree构造方法"></a>KD-Tree构造方法</h4><h5 id="结点-1"><a href="#结点-1" class="headerlink" title="结点"></a>结点</h5><p>KD-Tree每个结点存储以下信息：</p><p><code>l</code>,<code>r</code>：左右孩子下标</p><p><code>num[5]</code>：该结点所表示点的坐标</p><p><code>dim</code>：该结点所“切”的维度，$dim\in[0,d)$</p><p><code>up_bond[5],low_bond[5]</code>：每一个结点都代表在d维空间($2\leq d \leq5$)的高维立方体中“切”了一刀，这两个数组表示的就是这个“<strong>高维立方体</strong>”的上下界。对于根节点，我们将其上下界设为$\pm MAX$，其大小为$10^7$(因为题目规定每一个向量坐标不会超过这一区域，所以MAX起到代替$\infty$的作用)</p><p>为每个结点设置上下界的目的是，在查找最近邻时，能通过查询结点到某个一个结点所处的空间立方体的距离，判断是否需要剪枝（query节中进一步介绍）</p><h5 id="建立KD-Tree-1"><a href="#建立KD-Tree-1" class="headerlink" title="建立KD-Tree"></a>建立KD-Tree</h5><p>原始结点被输入后存储在数组<code>node</code>中，我们用函数<code>build(lp,rp,d0)</code>递归地建立KD-Tree，对每一个递归实例：</p><ol><li>将<code>node</code>数组中下标处于$[lp,rp]$之间的部分进行升序排序，排序依据是其第d0维的坐标大小</li><li>找到排序后区间内中位数的结点，用该结点的坐标来构造一个KD-Tree中的结点，并将该结点保存在<code>kdtree[index]</code>中</li><li>递归$[lp,rp]$的左半部分和右半部分（构造时需要判定左右区间是否为空，如果为空则不需要再为其建立子结点，此时其子结点下标指向0，也可视作空结点或垃圾结点），构造<code>kdtree[index]</code>的左右子树，同时更新其对应区域的上下界。</li></ol><p><strong>查找最近邻结点：</strong></p><p>每次查找某个结点q的最近邻时，用<code>min_len</code>记录最短距离，首先在KD-Tree中不断深探找到“离q最近”的叶节点，但这个“离q最近”是打引号的，正如KD-Tree的区间查找算法一样，由于每个结点的具体位置并不确定，所以深探找到的叶节点未必就是真正离q最近的结点。此时需要自下而上班地回溯深探过程中经过的所有结点，对于每一个路径上的非叶结点，首先应判断此结点<strong>距离q是否更近</strong>并更新<code>min_len</code>。此外，如果该结点的另一棵子树可能存在一个距离q比当前最短距离更短的结点。则需要对另一棵子树进行搜索，重复此操作，直至回溯至根节点。</p><p>那么如何判定一个结点的另一棵子树是否可能存在距离q最近的结点呢？我们给出两种剪枝方法：</p><ol><li>判断该结点对应的维度上，结点和q距离的平方是否小于<code>min_len</code>，实际上这一操作是求了q到这一边界的垂直距离，若小于，则需要搜索另一子树。</li><li>判断该结点另一个儿子对应的“高维立方体”p和q的距离，运算公式为$\Sigma_{i=0}^{d-1}(len(q,p,i))^2$，其中$len(q,p,i)$表示在第i维上q到高维立方体p的距离，显然当$q[i]\in[p.low_bond[i],p.up_bond[i]]$时，该维度的距离为0。若这一距离小于了<code>min_len</code>则有必要对其进行深探。</li></ol><p>显然第一种剪枝方法是弱于第二种剪枝方法的，但程序中实际上同时用了两种剪枝方法，原因是计算多维距离的平方这一操作虽然能够跟多的剪枝，但计算本身却要花费比方法一更多的时间。因此，我们采用了先用方法一粗判剪枝，再用方法二进一步细判的方法，提高剪枝效率。</p><h2 id="时间和空间复杂度的估算-3"><a href="#时间和空间复杂度的估算-3" class="headerlink" title="时间和空间复杂度的估算"></a>时间和空间复杂度的估算</h2><h5 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>本题的时间消耗来自两步操作：建立KD-Tree和对KD-Tree的查找，下面分别对其进行分析。</p><p>建立KD-Tree的时间复杂度可以这样分析：考虑一颗满树，其深度为k的层有$2^k$个结点，也就对应在递归建立是要创建$2^k$个递归实例，对于每一个递归实例，其包含的区间长度为$len \leq \frac {n}{2^{k}}$，每一个递归实例中，时间复杂度主要来自区间排序，其复杂度为$O(lenlog(len))$而每一层总的时间复杂度应为$O(lenlog(len) \cdot 2^k) = O(n(logn-k)) k=1,2,… logn$。KD-Tree共有$logn$层，因此总的时间复杂度为$O(n(logn)^2)$。</p><p>对KD-Tree的每次查找，上网查询得知在点随机均匀分布的情况下其时间复杂度为$O(logn)$，但因为个人能力有限，无法对一般情况进行证明，下面仅在一个特别情况，即所有点都严格均匀分布的情况下证明其复杂度。</p><p>可以这样考虑，对KD-Tree的每次查找，首先要深探至叶节点，其复杂度为$O(logn)$，将整个d维空间平均划分为边长为$\frac{a}{n^{1/d}}$的n个d维立方体，由于每个向量分布是均匀的，因此每个立方体内仅存在结点，深探所确定的叶结点与目标结点q之间的的距离，应不大于d维立方体体对角线的长度$L = \sqrt d\cdot a\cdot n^{-1/d}$，因为高维球体体积不太方便计算，下面考虑以$2L$为边长，q为中心做高维立方体$M$，球真包含于该立方体中，任何在该立方体之外的高维立方体和q的距离应大于$L$，而根据此前对每个立方体内结点只有1个的条件，$M$内所包含的结点个数肯定不会超过$2^dd^{d/2}$，因此获取他们中长度最小值的时间复杂度为$O(2^dd^{d/2})$，由于$d\leq5$，可以认为这个复杂度是$O(1)$的</p><p>因此，对于q次查找，其时间复杂度为$O(q(logn))$</p><p>因此，总的时间复杂度为$O(n(logn)^2+qlogn) \ n \leq 10^5, q \leq 2 \cdot10^5 \ d\leq5, \ n \leq 10^5, q \leq 2 \cdot10^5$</p><p><strong>空间复杂度</strong></p><p>KD-Tree存储在数组<code>kdtree</code>中，每个结点的struct需要存储18个int，因此其空间消耗为$O(18n)$，原始结点存储在<code>node</code>数组中，其大小也为$O(5n)$，除此以外，建树的递归实例个数应等于kd树的结点个数，节点个数不大于2n，查询递归的递归实例个数应等于访问结点的个数，递归深度为$O(log(n))$。因此总的空间复杂度应该为$O(n+log(n)) = O(n)$</p><h1 id="LAB2-HashFun-Report"><a href="#LAB2-HashFun-Report" class="headerlink" title="LAB2 HashFun Report"></a>LAB2 HashFun Report</h1><h3 id="不同哈希策略的实现"><a href="#不同哈希策略的实现" class="headerlink" title="不同哈希策略的实现"></a><strong>不同哈希策略的实现</strong></h3><p><strong>“坏”哈希函数：</strong>将每个字符的ascii值相加求和后对N取模。</p><script type="math/tex; mode=display">res = {\sum_{i=0}^{strlen(str)}{str[i]}}  \ \%N</script><p><strong>“好”哈希函数：</strong>将字符串根据ascii码值视作128进制数，将其转化为十进制后对N取模，和坏的哈希函数相比，这一函数能区分相同字符通过不同顺序组成的单词，因此更加均匀。</p><script type="math/tex; mode=display">res = {\sum_{i=0}^{strlen(str)}{str[i]}\cdot 128^i}  \ \%N</script><p><strong>双向平方试探策略：</strong>先通过哈希函数为字符串确定一个初始值(<code>init</code>中实现)，然后以该位置为轴双向平方试探。在派生类中定义变量成员<code>stride</code>记录上一次试探步长，每次试探更新stride，并根据变化前后stride确定新位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> old_stride = stride;<br>    <span class="hljs-keyword">if</span> (stride &lt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//向右试探</span><br>        stride = -stride + <span class="hljs-number">1</span>; <br>        <span class="hljs-type">int</span> next = ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)old_stride * old_stride) % table_size;<br>        next = (next + (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)stride * stride) % table_size;<br>        <span class="hljs-keyword">return</span> (last_choice + next) % table_size;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//向左试探</span><br>        stride = -stride;<br>        <span class="hljs-type">int</span> next = ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)old_stride * old_stride) % table_size;<br>        next = (next + (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)stride * stride) % table_size;<br>        <span class="hljs-keyword">return</span> (last_choice - next + table_size) % table_size;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>公共溢出区策略：</strong></p><p>原有<code>table_size</code>拿出一半设为缓冲溢出区，在<code>hashtable</code>构造函数中用向下转换判断冲突类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">overflow_probe* find = <span class="hljs-built_in">dynamic_cast</span>&lt;overflow_probe*&gt;(my_collision);<span class="hljs-comment">//相下转换，如果成功则是公共溢出策略</span><br><span class="hljs-keyword">if</span> (find) &#123;<br>    table_size =  size/<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>每次探测时，从<code>table_size</code>（溢出区起点）向后扫描</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (last_choice &lt; table_size)<br>    <span class="hljs-keyword">return</span> table_size;<br><span class="hljs-keyword">return</span> last_choice + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a><strong>测试数据</strong></h3><p><strong>构造方法：</strong>从<code>poj.txt</code>中提取所有信息，对其使用<code>random_shuffle</code>混排取前<code>in_num</code>项。数据生成有三个参数：</p><ul><li><code>in_num</code>：插入的字符串数量，字符串选取方法见上</li><li><code>sear_num</code>：询问次数，其中一半为成功查找，一半为失败查找，失败询问构造方法为<code>“#_#”+存在的字符串</code>，正确和失败查找交替出现</li><li>第三个参数为1时，将插入的键值字符串按字典序升序排序，否则不排序</li></ul><p>运行<code>makedata.bat</code>脚本可生成对应的数据</p><p><strong>数据特征：</strong>（表大小为200023）</p><div class="table-container"><table><thead><tr><th></th><th>in_num</th><th>sear_num</th><th>是否排序</th></tr></thead><tbody><tr><td>0</td><td>10000</td><td>8000</td><td>否</td></tr><tr><td>1</td><td>10000</td><td>8000</td><td>是</td></tr><tr><td>2</td><td>100000</td><td>80000</td><td>否</td></tr></tbody></table></div><ul><li>数据0和数据1相比，数据规模相同（但两次随机取，内容不完全一致），区别在于是否排序</li><li>数据2和数据0相比，数据规模扩大了10倍</li></ul><p>运行<code>run.bat</code>进行一组测试，运行的具体结果保存在result0,1,2三个文件夹下。</p><h3 id="分析结果"><a href="#分析结果" class="headerlink" title="分析结果"></a><strong>分析结果</strong></h3><ol><li>无论规模如何，插入值排序与否，<strong>好哈希都明显提高程序性能</strong>（最好300倍），因为好哈希让散列更均匀，减少冲突次数，排序对运行效率无明显影响。</li><li><strong>双向平放和线性试探相比，散列不均匀性能提升明显，均匀时无提升</strong>。可能是不均匀时，双向平方试探可迅速跳出聚集点。而散列均匀时，线性试探也能在附近迅速找到空位。</li><li><strong>不均匀散列，开放和封闭效率大体相同，均匀散列，封闭表现明显更优</strong>。另外装填因子较大时，封闭散列明显更占优。公共溢出区策略在处理表的局部比较“满”，再插入少量数据的情况下，可能表现更好。</li><li>字符串本身不均匀，可能导致“好”哈希函数生成的散列也不均匀，冲突增多。</li><li>可以记录实时的装填因子，对不同哈希策略，实验确定装填因子为多大时扩容或者缩容，使性能最优。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>DSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DSA PA2 REPORT</title>
    <link href="/2023/01/16/DSA-PA2-REPORT/"/>
    <url>/2023/01/16/DSA-PA2-REPORT/</url>
    
    <content type="html"><![CDATA[<h1 id="2-1-Risk-Report"><a href="#2-1-Risk-Report" class="headerlink" title="2-1 Risk Report"></a>2-1 Risk Report</h1><h2 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h2><p>本题的核心是如何构造一个类似于“队列”的数据结构，数据遵循先进先出的原则，且又能在O(1)时间内找到最大值。针对本题，我发现从$i−m_i$到$i-1$并不是每一个数字都有意义，实际上，只需要存储这样一个子序列就可以：<strong>该子序列B满足子列的每一项都严格大于所有原数组中项数大于这一项的元素</strong>，而每当 i 加一，只需要根据$m_i$删掉B的前几项，并从子序列的最后开始向前找到大于A[i-1]的项并删掉其后面的所有元素，这样就可以得到新的满足要求的B。</p><p>在搜索满足最大确诊病例在[0,p),[p,q)问题上，我采取了维护前缀和的方法，即<code>les_num[i]</code>表示最大确诊病例数小于 i 的总天数</p><h2 id="时间和空间复杂度的估算"><a href="#时间和空间复杂度的估算" class="headerlink" title="时间和空间复杂度的估算"></a>时间和空间复杂度的估算</h2><p><strong>时间复杂度：</strong>注意到维护B序列的两个指针lo和hi一定最多只会扫过一个一个元素一次，所以维护B序列的时间复杂度为$O(n)$，此外维护前缀和数组的时间复杂度为$O(m) \, m=2*10^{6}$，查询时间复杂度为$O(T)$。因此总复杂度为$O(m+n+T)$</p><p><strong>空间复杂度：</strong>程序开了三个长为n的数组，分别存储每日病例数，B数组每一项对应的病例数和B数组元素在原数组的下标。此外还开了两个长为m的数组存储每日前$i-m_i$日最大病例数和前缀和。总空间复杂度为$O(n+m)$</p><h1 id="CST-2-2-Report"><a href="#CST-2-2-Report" class="headerlink" title="CST 2-2 Report"></a>CST 2-2 Report</h1><h2 id="算法构思-1"><a href="#算法构思-1" class="headerlink" title="算法构思"></a>算法构思</h2><p>本题的实现思路主要参考教材中中缀表达式的算法。大体思想为：从左向右依次扫描一个每个字符，如果读到的是操作数则加入操作数栈，如果是操作符则需要比较和操作符栈栈顶的优先级关系，如果栈顶优先级更高则计算栈中两个操作数（本题中除括号外全部都是双目运算符），如果当前操作符优先级更高则入栈，如果相当则去掉栈顶操作符，并读取下一个位置的字符（对应去括号和\0匹配）。</p><p>为了完成本题我构造了两个类，<code>Stack</code>和<code>Poly</code>，前者用数组模拟了一个简单的栈结构，后者建立了一个多项式类实现其各项系数的存储以及加减乘次方运算。</p><p>具体实现时本题和教材也有一些不同：</p><ol><li>本题中操作数是一位位读入，且含有x，因此我设置了<code>tmp_num</code>变量来记录多位数，并且考虑x的情况。只有当读入下一个字符时才能知道之前的操作数读入是否结束，此时才将此前的操作数转化成Poly对象后入栈，这也是和教材不太一样的地方。</li><li>乘号省略。根据题目描述，乘号省略包括“)(，n(，x(，nx，)x”（n表示数字）这5种情况，所以每次读入字符时会判断一下这个字符和其前一个字符是否满足乘号省略的条件，如果满足则相当于先要让乘法和栈顶操作符比较，运算或入栈后再次读取当前字符（我使用一个<code>mul</code>变量来记录“读入当前字符时是否已经考虑乘号被省略”，从而确定是补乘号还是真正读取当前字符）</li><li>取模运算，每次运算后都要对1000000007取模，对于负数x，我采用$(x+1000000007)\mod1000000007$的方法</li></ol><p>一些算法优化：</p><ol><li>在读入字符串时，考虑到\^1这个运算本身对运算结果没有影响，为了避免不必要的次方运算，省略了所有\^1</li><li>每当构造一个多项式类时，都会用一个<code>_degree</code>变量来记录这个多项式类实例的最高位幂次，这样在乘法运算时不需要循环64*64次而只需要循环<code>_degree1</code>*<code>_degree2</code>次</li></ol><h2 id="时间和空间复杂度的估算-1"><a href="#时间和空间复杂度的估算-1" class="headerlink" title="时间和空间复杂度的估算"></a>时间和空间复杂度的估算</h2><p><strong>时间复杂度：</strong>程序时间复杂度主要来自三部分：字符串读入和出入栈计算。字符串读入显然是$O(n)$的，下面针对出入栈计算的时间复杂度进行分析。</p><p>每当扫描到一个字符，程序会判断此时运算数入栈（这里的运算数实际上是这个字符之前的字符组成的，比如123*x当扫描到*时123入栈）、运算符入栈或继续扫描，这个判断是线性的。计算时程序开了运算数和运算符两个栈，字符串中每个字符至多入其中一个栈一次并出栈一次（考虑到有些字符会整体作为一个数字入运算数栈，实际上出入栈的是运算数和运算符，其总和是小于字符串长度的）。此外，考虑到乘号省略情况，补全乘号后的字符串总长度也一定不会超过2n，最坏情况下也是线性的。运算数和运算符出栈时进行计算，每次计算的复杂的为常数次，因此总复杂度可以视作为 $O(n)$</p><p>综上所述，算法的时间复杂度为$O(n)$</p><p><strong>空间复杂度：</strong>每个栈均需开一个长为1000010的数组，共开两个栈，运算符栈每个元素的大小为char类型大小，运算数栈每个元素为一个Poly类，每个Poly类实例占空间大小主要为长为65的int数组，因此两个栈空间复杂度都可以视为$O(n)$。此外程序还开了一个长为1000010的字符串来存储中缀表达式。因此总空间复杂度为 $O(n)$</p><h1 id="LAB1-Zuma-Report"><a href="#LAB1-Zuma-Report" class="headerlink" title="LAB1 Zuma Report"></a>LAB1 Zuma Report</h1><h2 id="01"><a href="#01" class="headerlink" title="01"></a>01</h2><p><strong>错误类型</strong></p><p>Runtime Error</p><p><strong>错误原因</strong></p><p>第19行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">play</span>(left - <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>未考虑到如果left本身变为0的时候left-1小于0的情况，即某种操作使从最首字符开始到操作位置之间的字符都被消掉，即会触发该错误</p><p><strong>测例构造</strong></p><p>相应测例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">AABBAB<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span> <span class="hljs-selector-tag">B</span><br></code></pre></td></tr></table></figure><p>标准答案：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">B</span><br></code></pre></td></tr></table></figure><p>构造思路：只需要构造某种操作使从首字符开始到操作位置之间的字符都被消掉的情况即可。上例中，当执行第一次消除后，程序运行到第19行时<code>left=0</code>此时会调用函数<code>play(- 1)</code>，而执行到第十行<code>a.at(rank);</code>此时<code>rank=-1</code>会导致函数访问数组错误，导致RE。</p><h2 id="02"><a href="#02" class="headerlink" title="02"></a>02</h2><p><strong>错误类型</strong></p><p>Runtime Error</p><p><strong>错误原因</strong></p><p>未考虑到字符串被消除为空串后<code>a.at(0)</code>会越界访问</p><p><strong>测例构造</strong></p><p>相应测例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">AABBAA<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span> <span class="hljs-selector-tag">B</span><br></code></pre></td></tr></table></figure><p>标准答案：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">（空串）<br></code></pre></td></tr></table></figure><p>构造思路：只需要构造某种操作使字符完全被消除，得到空串即可。此时完全消除字符串后变量<code>next</code>=0，函数调用<code>play(0)</code>，在下一个实例中，第十行调用<code>at(0)</code>时会导致数组越界访问</p><h2 id="03"><a href="#03" class="headerlink" title="03"></a>03</h2><p><strong>错误类型</strong></p><p>Time Limit Exceeded</p><p><strong>错误原因</strong></p><p>该算法中用到的<code>erase</code>和<code>insert</code>方法的时间复杂度均是$O(n)$，最坏情况下，整体复杂度为$O(mn)$，效率过低会导致超时问题</p><p><strong>测例构造</strong></p><p>相应测例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">AABBCCDDEEFFGGHHIIJJKKLLMMNNOOQQPPRRSSTTUUVVWWXXYYZZ……<br><span class="hljs-number">500000</span><br><span class="hljs-number">0</span> <span class="hljs-selector-tag">A</span><br><span class="hljs-number">0</span> <span class="hljs-selector-tag">B</span><br>……<br></code></pre></td></tr></table></figure><p>标准答案：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">UUVVWWXXYYZZAABBCC……<br></code></pre></td></tr></table></figure><p>构造思路：使n和m均达到数据大小上限，并且每一次操作都有一定的复杂度（比如让每次操作都消除一些字符串）便会导致超时。</p><h2 id="04"><a href="#04" class="headerlink" title="04"></a>04</h2><p><strong>错误类型</strong></p><p>Wrong Answer</p><p><strong>错误原因</strong></p><p>代码第12行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (left &gt; <span class="hljs-number">0</span> &amp;&amp; a.<span class="hljs-built_in">at</span>(left) == color) --left;<br></code></pre></td></tr></table></figure><p>操作时由于left未加1导致每次删除的字符串左侧会多删除一个，因此导致错误结果</p><p><strong>测例构造</strong></p><p>相应测例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">ABBC<br><span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-selector-tag">B</span><br></code></pre></td></tr></table></figure><p>标准答案：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">AC</span><br></code></pre></td></tr></table></figure><p>构造思路：构造一个待删除串左侧有不应该被删除的字符即可，上例中A就会被错误删除，消除时left=0，right=3，则<code>erase(left, size)</code>会删除字符串ABB，导致WA。</p><h2 id="05"><a href="#05" class="headerlink" title="05"></a>05</h2><p><strong>错误类型</strong></p><p>Wrong Answer</p><p><strong>错误原因</strong></p><p>代码第27行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cin &gt;&gt; a;<br></code></pre></td></tr></table></figure><p>输入字符串时用的<code>cin</code>而非<code>getline</code>，无法读入空字符串，不满足输入要求</p><p><strong>测例构造</strong></p><p>相应测例：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span>A<br></code></pre></td></tr></table></figure><p>标准答案：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span><br></code></pre></td></tr></table></figure><p>构造思路：构造一个空串即可制造错误，<code>cin&gt;&gt;a</code>无法读入。</p><h2 id="06"><a href="#06" class="headerlink" title="06"></a>06</h2><p><strong>错误类型</strong></p><p>Wrong Answer</p><p><strong>错误原因</strong></p><p>当某一块输入大于$2^{12}$时，程序没有进行重组块操作，溢出的数据可能覆盖后面的块</p><p><strong>测例构造</strong></p><p>相应测例：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ</span>……<br><span class="hljs-number">2049</span><br><span class="hljs-number">1</span> <span class="hljs-variable">A</span><br><span class="hljs-number">1</span> <span class="hljs-variable">B</span><br><span class="hljs-number">1</span> <span class="hljs-built_in">C</span><br><span class="hljs-number">1</span> <span class="hljs-built_in">D</span><br><span class="hljs-number">1</span> <span class="hljs-built_in">E</span><br><span class="hljs-number">1</span> <span class="hljs-variable">F</span><br><span class="hljs-number">1</span> <span class="hljs-variable">G</span><br><span class="hljs-number">1</span> <span class="hljs-variable">H</span><br>……<br></code></pre></td></tr></table></figure><p>标准答案：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">AUTSRQPONMLKJIHGFEDCBA……<br></code></pre></td></tr></table></figure><p>构造思路：构造一个使某一块长度大于$2^{12}$的操作即可使块数据溢出，上例中，会不断向位置1处添加字符且不会发生消除，在添加$2^{11}$个后，<code>p[0]</code>中元素已满，此时再在第0块中添加一个字符且不可消去时，<code>p[0]</code>溢出覆盖后面的内存，导致错误结果</p><h2 id="07"><a href="#07" class="headerlink" title="07"></a>07</h2><p><strong>错误类型</strong></p><p>Wrong Answer</p><p><strong>错误原因</strong></p><p>第96行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (l.second &lt; <span class="hljs-number">0</span> &amp;&amp; l.first &gt;= <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>应改为while循环，否则会导致当某次消除需要跳过一个已经为空的块儿时无法跳过（if仅使<code>l.first</code>减了一次）</p><p><strong>测例构造</strong></p><p>相应测例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">CAABBAABB……AAD（第一块）AABB……AABB （第二块）DE<br><span class="hljs-number">2048</span><br><span class="hljs-number">1</span> A<br><span class="hljs-number">1</span> B<br><span class="hljs-number">1</span> A<br><span class="hljs-number">1</span> B<br>……<br><span class="hljs-number">2</span> A<br><span class="hljs-number">2</span> B<br><span class="hljs-number">2</span> A<br><span class="hljs-number">2</span> B<br>……<br><span class="hljs-number">2</span> D<br></code></pre></td></tr></table></figure><p>标准答案：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">CE</span><br></code></pre></td></tr></table></figure><p>构造思路：构造一个消除操作恰好要越过一个空块儿的测例即可，算法无法越过空快向前读取重复的字符，比如上例中，在最后一个D输入前，字符串会消除为“CD(第一块)（第二块为空）DE（第三块），此时在2处插入D，此时执行第96行时，程序无法从第三块跨过第二块看到第一块中的D，从而无法将D连消，导致产生CDDDE这样的错误结果</p><h2 id="08"><a href="#08" class="headerlink" title="08"></a>08</h2><p><strong>错误类型</strong></p><p>Wrong Answer</p><p><strong>错误原因</strong></p><p>第92行处未进行while(1)操作，会导致无法连续消除</p><p><strong>测例构造</strong></p><p>相应测例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">AABBAA<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span> B<br></code></pre></td></tr></table></figure><p>标准答案：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">（空串）<br></code></pre></td></tr></table></figure><p>构造思路：构造一个会发生连续消除的样例即可</p><h2 id="09"><a href="#09" class="headerlink" title="09"></a>09</h2><p><strong>错误类型</strong></p><p>Runtime Error</p><p><strong>错误原因</strong></p><p>第130行处未判定<code>l.first</code>和<code>r.first</code>是否相等，可能出现两个相等即删除的字符串但没有跨越块儿的情况，这时候plen可能会记录错误的块长度大小数据，从而在<code>p2a</code>函数中<code>memcpy</code>函数移动数组时产生访问越界的问题</p><p><strong>测例构造</strong></p><p>相应测例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">AABBCC<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span> B<br></code></pre></td></tr></table></figure><p>标准答案：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">AACC</span><br></code></pre></td></tr></table></figure><p>构造思路：构造一个消除只发生在一个块内，且消除字符串的前后都有需要被保留的字符串即可，这样就会导致plen记录了错误的长度大小（负值），本例中，<code>l.second</code>=1,<code>r.seconde</code>=5,由于<code>l.first</code>与<code>r.first</code>相等，因此第135行计算出的<code>len</code>为-3，而赋到<code>size_t</code>类型的plen[0]中时会被转换成大整数18446744073709551613这样一个很大很大的数，远远大于p[i]的大小（$2^{12}$），导致在函数<code>p2a</code>中执行 <code>memcpy</code>时，将一个取了大于p[i]大小的数组内容，这就产生了了数组越界。</p><h2 id="10"><a href="#10" class="headerlink" title="10"></a>10</h2><p><strong>错误类型</strong></p><p>Wrong Answer</p><p><strong>错误原因</strong></p><p>第147行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l.first; i &lt; r.first; i++)<br>    plen[i] = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>i从<code>l.first</code>开始，并将其长度置为0，实际上第i块长度并不一定达到零，这就会导致最后在<code>p2a</code>组装回去中各块出现长度不对应的情况，在a长度计算正确的情况下，会导致组装错误</p><p><strong>测例构造</strong></p><p>相应测例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">BAABBAABB……AABBC<br><span class="hljs-number">1</span><br><span class="hljs-number">2048</span> B<br></code></pre></td></tr></table></figure><p>标准答案：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">BAABBAABB……AAC<br></code></pre></td></tr></table></figure><p>构造思路：构造一个消除会跨越块发生，且消除字符的前后都有剩余字符的测例即可。本例中，数组总长计算没有错，但<code>plen[0]</code>会被赋成0，所以导致<code>p2a</code>中第一块部分并没有被组装回原数组a中，只有<code>p[1]</code>中剩余的“C”会被复制到a[0]开始的内存中，而后面的部分实际上是a数组原来的剩余，最终导致输出C（来自<code>p[1]</code>）AABBAABB……（原数组剩余）的结果，产生错误答案</p>]]></content>
    
    
    
    <tags>
      
      <tag>DSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DSA PA1 REPORT</title>
    <link href="/2023/01/15/DSA-PA1-REPORT/"/>
    <url>/2023/01/15/DSA-PA1-REPORT/</url>
    
    <content type="html"><![CDATA[<h1 id="CST-1-2-Graphics-Report"><a href="#CST-1-2-Graphics-Report" class="headerlink" title="CST 1-2 Graphics Report"></a>CST 1-2 Graphics Report</h1><h2 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h2><p>交点的个数问题可以转化成该点所在区域（考虑到没有线段相交这个条件）即可，因此此算法实现分为两步：对x、y点的排序以确定每条线段和查找确定点所在的区域。</p><p>排序实现参考了课本中的归并排序算法来实现，不同处在于一次实现了x和y两个数组的排序（两个数组大小一样所以每次划分的左右两段长度也一样，可以在一个函数中实现）</p><p>查找时基于二分查找的思路，确定点的区域时每次比较时利用了叉乘进行判断，从而避免出现除法，考虑到数据范围会超出int，判断时使用long long数据类型，同时还需考虑边界情况（位于最左侧线段的左侧和最右侧线段的右侧）</p><h2 id="时间和空间复杂度的估算"><a href="#时间和空间复杂度的估算" class="headerlink" title="时间和空间复杂度的估算"></a>时间和空间复杂度的估算</h2><p><strong>时间复杂度：</strong>归并排序算法复杂度为 $O(nlogn)$，二分查找每次算法复杂度为 $    O( log (n) ) $ ，总复杂度为 $O((n+m)logn)$</p><p><strong>空间复杂度：</strong>全局变量<code>x_0</code>和<code>y_0</code>存储了坐标轴上的点的信息，占用空间为2n，归并排序每次合并时新开了<code>x_1</code>和<code>y_1</code>数组，合并后会立即删除，不会保留到之后的合并中，占用空间为2n，二分查找本身不占用空间，因此总空间占用为$O(n)$</p><h1 id="CST-1-3-filename-Report"><a href="#CST-1-3-filename-Report" class="headerlink" title="CST 1-3 filename Report"></a>CST 1-3 filename Report</h1><h2 id="算法构思-1"><a href="#算法构思-1" class="headerlink" title="算法构思"></a>算法构思</h2><p>因为“插入字符”和“删除字符”操作实际上是可以交换顺序的，所以每种从A到B之间的变换，实际上都可以转换成从A删除字符到A和B的某个公共子序列，然后再插入字符直到得到B。要求k步内能否从A变成B，实际上就是用动态规划方法求A和B最长公共子序列的问题。</p><h2 id="实现过程中遇到的问题"><a href="#实现过程中遇到的问题" class="headerlink" title="实现过程中遇到的问题"></a>实现过程中遇到的问题</h2><p>具体实现时需要解决以下几个问题：1.由于500000*500000会超过存储空间范围，查询网络后发现可以采用滚动数组方法，转换为2*500000大小的数组。2.使用一般的求公共子序列算法会超时，但考虑到k步的限制，所以每次不需要枚举500000次，而只需要看$((n &gt; m ? n - m : m - n) + k) / 2 + 1$范围内即可（相当于只用看对角线附近的）。</p><h2 id="时间和空间复杂度的估算-1"><a href="#时间和空间复杂度的估算-1" class="headerlink" title="时间和空间复杂度的估算"></a>时间和空间复杂度的估算</h2><p><strong>时间复杂度：</strong>DP是算法的关键，时间复杂度为 $O(kn)$（不妨令n&gt;m，$ n \leq 501000 $）</p><p><strong>空间复杂度：</strong>主要占用空间的为memo数组，大小为2*501010，和两个长为501000的char数组，因此算法空间复杂度为$O(n)$</p>]]></content>
    
    
    
    <tags>
      
      <tag>DSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2018/01/05/hello-world/"/>
    <url>/2018/01/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
