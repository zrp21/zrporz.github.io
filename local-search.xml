<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>DSA PA4 REPORT</title>
    <link href="/2023/01/16/DSA-PA4-REPORT/"/>
    <url>/2023/01/16/DSA-PA4-REPORT/</url>
    
    <content type="html"><![CDATA[<h1 id="CST-4-1-Report"><a href="#CST-4-1-Report" class="headerlink" title="CST 4-1 Report"></a>CST 4-1 Report</h1><h2 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h2><p>本题需要维护这样一个数据结构：对于$\forall i, i\in[0,n)$</p><ul><li>存有$[max(0,i-k-1),min(n-1,i+k+1)]$这一区间窗口内所有原件的信息</li><li>可以查询这一范围内和i异或值最大的字符串id</li><li>可以动态删去某个字符串和添加某个字符串到这个数据结构中</li></ul><p>基于此，我们最终选择<strong>字典树</strong>这一数据结构，下面对其进行详细介绍。</p><h4 id="字典树：规则"><a href="#字典树：规则" class="headerlink" title="字典树：规则"></a>字典树：规则</h4><p>对字典树的理解可以类比有限状态自动机（DFA），本题中字母表$\Sigma = \{0,1\}$，树的根节点相当于是自动机入口。从入口开始，每经过一个结点，01串将自己的第一个字符取出，如果是0则转向结点的左子树，是1则转向右子树，直到走到树的叶结点为止，每个叶结点可以视作自动机的一个终态</p><p>对于每个<strong>结点</strong>，用<code>cnt</code>存储路径经过这个结点的字符串数量</p><p>对于每个<strong>叶结点</strong>，还要记录这个终态对应的字符串的id值，由于可能存在多个id值的字符串相同的情况，这里的id值记录的是所有存在树中对应这一终态的字符串id最小值，$ _id = min(\{id | str[id] \land  id\in [max(0,i-k-1),min(n-1,i+k+1)]\}) $，这一操作是为了满足题目要求中“<strong>输出所有窗口内和id=i异或值最大的字符串id的最小值</strong>”要求。</p><h4 id="字典树：初始化"><a href="#字典树：初始化" class="headerlink" title="字典树：初始化"></a>字典树：初始化</h4><p>由于本题字母表中只有两个字母，所以字典树实际上是一棵高度等于64的二叉树。每个结点的左右子树分别代表接受0和1后转移到的状态。</p><h4 id="字典树：动态变化"><a href="#字典树：动态变化" class="headerlink" title="字典树：动态变化"></a>字典树：动态变化</h4><p>每当我们变换窗口时，字典树中都可能会插入一个字符串并删除一个字符串（当窗口移动到两端附近时，也可能出现不删除或不插入的情况）</p><h4 id="字典树：插入"><a href="#字典树：插入" class="headerlink" title="字典树：插入"></a>字典树：插入</h4><p>考虑插入一个64位的01字符串<code>original[i]</code>。</p><p>从根节点开始，按照字典树转向规则深探，如果结点并没有对应的孩子，则创建它，同时我们将沿途经过的所有结点计数值加1，表示经过这一节点的字符串多了一个。</p><p>探到叶结点后，更新叶结点的id值，这要求我们插入的字符串一定是当前窗口中的最小值，<strong>因此，我们的窗口应该是从右往左移动，而非从左往右移动。</strong></p><h4 id="字典树：删除"><a href="#字典树：删除" class="headerlink" title="字典树：删除"></a>字典树：删除</h4><p>考虑删除一个64位的01字符串<code>original[i]</code>，这一字符串此前一定已经插入在树中。</p><p>从根节点开始，按照字典树转向规则深探，同时我们将沿途经过的所有结点计数值减1，表示经过这一节点的字符串少了一个。</p><h4 id="字典树：查询"><a href="#字典树：查询" class="headerlink" title="字典树：查询"></a>字典树：查询</h4><p>考虑查询j，使得$j\neq i \land j \in [max(0,i-k-1),min(n-1,i+k+1)]$且<code>original[j]</code>和<code>original[i]</code>异或值最大。异或值查询满足<strong>贪心条件</strong>，只需要每次都转向异或值最大的方向即可，具体来说就是如果有结点两个孩子的话，接收0后转向右子树，接收1后转向左子树，这样最终到达的终态得到一个id值即是所求结果。</p><p>一般来说，上述办法找到的id值和i是不同的，除非一种情况：<strong>i=0且窗口内所有字符串相同，此时找到的id为0</strong>，但根据题目要求，id值应该为1，这里需要特判一下。</p><h2 id="时间和空间复杂度的估算"><a href="#时间和空间复杂度的估算" class="headerlink" title="时间和空间复杂度的估算"></a>时间和空间复杂度的估算</h2><p><strong>时间复杂度：</strong>每个元件至多被插入一次、删除一次，对于每次插入、删除操作，时间复杂度均正比于树高$O(64)=O(1)$，而对n个元件，我们的时间复杂度为$O(n)$</p><p><strong>空间复杂度：</strong>考虑到每个字典树的结点都可能代表一个字符，字典树的总结点个数应该不大于$O(64n)$，其它的数组空间规模也符合$O(n)$，总的空间复杂度应是$O(n)$的。但这只是一个相当宽泛的上界，存在被卡常的可能。考虑到字典树靠近根节点的结点应该是可以复用的，下面对其进行更精细的分析：</p><p>考虑n的最大值$n=5\times10^5$，假设某一时刻窗口能够涵盖所有的字符串，n对2取对数后可以得到，前19层的树是满的，从第20层开始每个字符串对应一条单链，这样的结点数就达到了理论上的最大值，总个数为$2^{20}+5\times10^5\times(64-19)=23548576$。因此，理论上字典树占的空间为359.32MB（每个结点存4个int，空间大小为16byte）</p><p><code>bool original[500001][64]</code>数组存储了所有原件字符串信息，空间复杂度为$O(64n)=O(n)$，占空间大小为$64\times500001B=30.51MB$</p><p>因为窗口是从右往左移动的，还需要<code>int res[500001]</code>数组来存储结果，空间复杂度为$O(n)$，占空间大小为$4\times500001B=1.97MB$</p><p>总的占空间大小为$359.32+30.51+1.97=391.8MB&lt; 512MB$</p><h1 id="CST-4-2-Report"><a href="#CST-4-2-Report" class="headerlink" title="CST 4-2 Report"></a>CST 4-2 Report</h1><h2 id="算法构思-1"><a href="#算法构思-1" class="headerlink" title="算法构思"></a>算法构思</h2><p>本题所要完成的任务和Dijkstra算法相似，都是求从起点到终点的最短距离，不同之处在于权重由边转移到了点，但这并不会对算法本身造成过大的改动；另一个不同是本题要求还要求出最短路径的数量，这需要我们基于Dijkstra算法进行改进。此外，如果使用蛮力Dijkstra算法的话时间复杂度为$O(n^2)$代入n简单计算便可知会导致超时，因此我们需要设计一种数据结构，能够返回当前非永久性节点中路径长度最小的结点，避免$O(n)$的轮询，优先级二叉堆可以满足我们的这一需求。</p><h4 id="建图过程"><a href="#建图过程" class="headerlink" title="建图过程"></a>建图过程</h4><p>每个游戏关卡存储为一个<code>Node</code>结点，每个结构体中存有以下成员变量：</p><ul><li><code>minlen</code>：从起点开始，到结点的最短长度</li><li><code>num</code>：到结点的最短路径的数量</li><li><code>time</code>：通过结点所需的用时</li><li><code>flag</code>：标记结点是否为永久结点</li></ul><p>边的信息保存在<code>Edge e</code>数组中，本题中每条边都是一条无向边，我们将其转化为两条方向相反的边，这样便于建立以起始点为索引的链表，链表表头存储在数组<code>head</code>中。</p><h4 id="设计优先级二叉堆"><a href="#设计优先级二叉堆" class="headerlink" title="设计优先级二叉堆"></a>设计优先级二叉堆</h4><p>二叉堆中每一个结点<code>PQNode</code>存储两个变量：</p><ul><li><code>id</code>：记录这个点对应结点的id值</li><li><code>num</code>：记录<strong>在结点插入时</strong>，到达该结点的最短路径</li></ul><p>二叉堆堆顶的元素满足，堆顶的结点的<code>num</code>值为全堆最小。</p><p>每当插入一个<code>PQNode</code>结点时，我们将其添加在当前堆的末尾，然后根据其<code>num</code>值”上浮“。删除一个<code>PQNode</code>结点时，我们首先记录堆顶的值，然后将其和堆尾元素交换，随后让堆顶元素”下沉“。这些都是二叉堆的基本操作。</p><h4 id="Dijkstra算法：初始化"><a href="#Dijkstra算法：初始化" class="headerlink" title="Dijkstra算法：初始化"></a>Dijkstra算法：初始化</h4><p>一开始，将起点的最短路大小赋为该关卡的耗时，将其添加到堆中，并将起点设为工作结点</p><h4 id="Dijkstra算法：过程"><a href="#Dijkstra算法：过程" class="headerlink" title="Dijkstra算法：过程"></a>Dijkstra算法：过程</h4><p>每次确定一个工作结点后，将其变为永久结点，并更新所有和它相邻的非永久性结点的最短路径值和最短路径数量，对于工作结点p和其相邻结点q，更新规则如下：</p><ul><li>$minlen(p)+time(q)&gt;minlen(q)$，保持q的最短路径距离和最短路径数不变</li><li>$minlen(p)+time(q)=minlen(q)$，q的最短路径距离不变，最短路径数在原有基础上加上$num(q)$</li><li>$minlen(p)+time(q)&lt;minlen(q)$，q的最短路径距离更新为$minlen(p)+time(q)$，最短路径数更新为$num(q)$</li></ul><p>这样就实现了同时记录最短路径长度和最短路径数。</p><p>将所有相邻结点更新完后，从优先级二叉堆中不断取出堆顶元素p，直到取出的p表示的是一个现在为非永久节点为止，此时的p一定是所有非永久结点中最短路径距离最小的结点。将p确定新的工作结点，重复上述过程，直到终点变为永久结点为止。</p><h2 id="时间和空间复杂度的估算-1"><a href="#时间和空间复杂度的估算-1" class="headerlink" title="时间和空间复杂度的估算"></a>时间和空间复杂度的估算</h2><p><strong>时间复杂度：</strong>由于每条边至多只有一个方向上的结点会被插入到二叉堆中，所以二叉堆结点数至多为m，二叉堆的插入和删除操作时间复杂度均正比于其树高，也就是$O(log(m))$，由于每条无向边至多会插入一次，因此插入的总时间复杂度为$O(mlog(m))$，删除也是同理，每次取出的堆顶元素不一定就是我们需要的那个结点，可能某次寻找工作结点时需要多次取出堆顶元素，但取出的总元素个数不会大于堆中最大元素个数，因此取出操作的时间复杂度上界应该也是$O(mlog(m))$。因此，算法的时间复杂度为$O(mlog(m))$</p><p>除此以外，对结点和边的读入操作其复杂度为$O(n)$和$O(m)$，考虑题目并没有给出m和n的大小关系，但m和n具有相同的量级，因此总的时间复杂度也可以写作$O((m+n)log(m))$，这样写可以涵盖n很大但m很小的情况。</p><p><strong>空间复杂度：</strong>存储边的数组和二叉堆数组空间复杂度均为$O(m)$（这两个数组我都开到了2m的大小，实际上二叉堆数组大小开到m已经足够），存储邻接表表头的的数组和关卡结点数组的空间复杂度均为$O(n)$，因此，总的空间复杂度为$O(m+n)$</p><h1 id="CST-LAB3-BBST-Report"><a href="#CST-LAB3-BBST-Report" class="headerlink" title="CST LAB3 BBST Report"></a>CST LAB3 BBST Report</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>本题我选择实现的数据结构为Splay树和Avl树，下面对这两个数据结构的核心功能和公共接口进行说明。</p><h3 id="1-树结构实现"><a href="#1-树结构实现" class="headerlink" title="1. 树结构实现"></a>1. 树结构实现</h3><h4 id="1-1-二叉树结点-BinNode"><a href="#1-1-二叉树结点-BinNode" class="headerlink" title="1.1 二叉树结点 BinNode"></a>1.1 二叉树结点 <code>BinNode</code></h4><p>仿照课本的继承关系，Splay树和Avl树中的二叉树结点均用结构体<code>BinNode</code>实现，其中存储数据为：</p><ul><li>data：结点键值</li><li>parent，l，r：父节点和左右孩子结点的数组下标</li><li>height：结点高度（在Avl树中使用）</li><li>index：该结点对应的数组下标</li></ul><h4 id="1-2-旋转-zag-zig"><a href="#1-2-旋转-zag-zig" class="headerlink" title="1.2 旋转 zag,zig"></a>1.2 旋转 <code>zag</code>,<code>zig</code></h4><p>这同样是两种树可以通用的函数，函数参数为需要旋转的结点<code>v</code>下标<code>id</code>，<code>v</code>和其左右孩子构成了一个”旋转单元“，<code>zag</code>逆时针旋转，<code>zig</code>顺时针旋转。旋转重置父子之间指向关系（包括三个结点之间相互关系和他们与父亲或孩子结点之间的关系），并更新高度。</p><h4 id="1-3-伸展-Splay"><a href="#1-3-伸展-Splay" class="headerlink" title="1.3 伸展 Splay"></a>1.3 伸展 <code>Splay</code></h4><p><code>Splay</code>操作每次将最后访问的结点伸展至根，为了避免出现逐层旋转在一字型下可能会导致树高过高的问题，采用双层伸展的办法。当祖孙三代呈一字型时，先旋转祖父结点再旋转父亲结点；当祖孙三代呈之字型时，先旋转父亲结点再旋转祖父结点（其实也可以先祖父再父亲，主要为了和教材保持一致），旋转时，还需对父亲和祖父是否存在等情况做讨论，处理特殊情况。</p><h4 id="1-4-搜索-search"><a href="#1-4-搜索-search" class="headerlink" title="1.4 搜索 search"></a>1.4 搜索 <code>search</code></h4><p>基础搜索算法和普通二叉搜索树一致，都是从根节点开始深探直至找到对应节点或发生不存在孩子节点的情况，搜索过程中<code>_hot</code>始终指向查找结点的父节点。</p><p>Splay树要求对每一次查找操作都要将查找到的结点伸展至根，因此每次搜索后需要做一次判定：如果查找成功，则将命中结点伸展至根，否则将<code>_hot</code>结点伸展至根。</p><h4 id="1-5-插入-insert"><a href="#1-5-插入-insert" class="headerlink" title="1.5 插入 insert"></a>1.5 插入 <code>insert</code></h4><p>首先通过搜索函数<code>search</code>找到结点需要插入的位置，由于Splay树的搜索函数内置了伸展操作，所以执行完搜索后_hot结点就已伸展至根，此时根据插入节点和_hot结点的关系判断插入到其左孩子还是右孩子即可，Avl树无需伸展，但插入后需沿深探路径回溯至根，沿路检查结点是否处于平衡状态，如果遇到非平衡状态，则对该结点进行重平衡操作，教材给出的是3+4重构，这里并未对3+4重构进行封装，而是通过分情况讨论选择旋转方式zig/zag实现，当发现一个失衡结点并重平衡后，即可退出不再上溯。</p><h4 id="1-6-删除-remove"><a href="#1-6-删除-remove" class="headerlink" title="1.6 删除 remove"></a>1.6 删除 <code>remove</code></h4><p>首先还是搜索需要删除的结点并将其伸展至根，删除该结点后，取其后继<code>succ</code>为新的根节点，如果没有后继，则取其前驱<code>pred</code>。</p><p>对于Avl树，删除后需要沿路检查各父亲结点是否失衡并使其重平衡，而Splay树则不需要这样的操作。</p><h3 id="2-复杂度分析"><a href="#2-复杂度分析" class="headerlink" title="2. 复杂度分析"></a>2. 复杂度分析</h3><h4 id="2-1-Avl树"><a href="#2-1-Avl树" class="headerlink" title="2.1 Avl树"></a>2.1 Avl树</h4><p>根据讲义P540页的分析，考虑高为h的结点最少的Avl树，其结点个数满足递推式$S(h)=1+S(h-1)+S(h-2)$，因此，高度为h的AVL树，至少包含$S(h)=fib(h+3)-1$个结点，由于斐波那契数列通项公式为 $fib(n)=\frac{1}{\sqrt 5}[(\frac{1+\sqrt 5}{2})^n-(\frac{1-\sqrt 5}{2})^n]$，由于斐波那契数列大致呈指数增长，因此含n个结点的Avl树其最大树高也是$O(logn)$的，由于满二叉树，也就是最”胖“的Avl树高度也是$O(logn)$，所以这个界是严格的。</p><p>Avl树的搜索和普通二叉树是相同的，其算法复杂度均正比于树高$O(logn)$，而对于插入操作，在插入后只需要沿路回溯至非失衡结点重构，由于回溯深度不会超过深探的深度，也就是树高$O(logn)$，而重构操作本身又是$O(1)$的，因此插入算法时间复杂度也是$O(logn)$。删除操作和插入不同之处在于要一路回溯至根才停止，沿路重构所有失衡结点，而由于访问的结点个数和深探深度相同，因此最坏情况下也只需重构$O(logn)$次，因此删除操作的算法时间复杂度也是$O(logn)$。</p><p>综上，Avl树的搜索、插入、删除操作时间复杂度均为$O(logn)$，共m次操作，因此总的时间复杂度为$O(mlogn)$</p><h4 id="2-2-Splay树"><a href="#2-2-Splay树" class="headerlink" title="2.2 Splay树"></a>2.2 Splay树</h4><p>根据讲义，我们需要用势能分析的方法来分析其均摊复杂度。首先，我们定义Splay树中结点v的势能为$\phi(v)=log|v|$，$|v|$表示这个结点子树的结点个数，树的势能定义为$\Phi(T)=\Sigma_{v\in T}\phi(v)$，直觉告诉我们，越平衡的树，其势能越小，越倾侧的树，其势能越大，具体来说，单链的势能最大，为$log(n!)=O(nlogn)$。</p><p>给出势能的定义后，我们开始计算时间复杂度，首先，我们将问题简化，考虑单次将结点$x$旋转至根的时间复杂度，其他操作均可以视作这个操作的组合。而对于每次旋转至根的操作，可以分为两部分讨论：双旋和单旋。前者我们将用势能增量来表示复杂度，而后者由于单次旋转复杂度本身难以计算，但我们可以考虑经过m次旋转至根的操作后，单旋造成的时间复杂度本身应该不会不会超过树自身势能的bound，即$O(mlogn)$，我们只需要最后将其加上就可以，</p><p>下面我们重点分析单次双旋至根的时间复杂度，分为两种情况讨论：一字型和之字型</p><ul><li>一字型</li></ul><p>假设x,y,z分别为孩子，父亲，爷爷结点，旋转后对应的结点为x’,y’,z’。变化后的总势能为</p><script type="math/tex; mode=display">\begin{align} \Delta \Phi(T)&=\phi(x')+\phi(y')+\phi(z')-\phi(x)-\phi(y)-\phi(z)  \\&= \phi(y')+\phi(z')-\phi(x)-\phi(y)\end{align}</script><p>而复杂度应该为$O(1)+\Delta \Phi(T)$，下面我们尝试将其放缩为$k(\phi(x’)-\phi(x))，k为常数$的形式，由于常数k本身值是多少并不重要，所以我们可以将$O(1)$视作1来简化计算。我们可以先做这样的放缩：</p><script type="math/tex; mode=display">1+\Delta \Phi(T)\leq \phi(y')+\phi(z')-\phi(x)-\phi(y)\leq 1+ \phi(x')+\phi(z')-2\phi(x)</script><p>另一方面，根据一字型变化满足的条件，我们有：$|x’|=|z’|+|x|+1$，利用均值不等式我们可以进一步得到</p><script type="math/tex; mode=display">\phi(x)+\phi(z')-2\phi(x') = log\frac{|x||z'|}{|x'|^2}\le log\frac{|x'|^2}{4|x'|^2}=log\frac{1}{4}<-1</script><p>代入原式，可以解得</p><script type="math/tex; mode=display">\begin{align}1+\Delta \Phi(T) &\le 1+ \phi(x')+\phi(z')-2\phi(x)\\&<\phi(x')+\phi(z')-2\phi(x)-(\phi(x)+\phi(z')-2\phi(x'))\\&=3(\phi(x')-\phi(x))\end{align}</script><p>旋转结束后，总复杂度应小于$3(\phi(root)-\phi(x_0))&lt;3logn$</p><ul><li>之子型</li></ul><p>假设x,y,z分别为孩子，父亲，爷爷结点，旋转后对应的结点为x’,y’,z’。同样我们可以得到变化后的总势能为</p><script type="math/tex; mode=display">\begin{align} \Delta \Phi(T)&=\phi(x')+\phi(y')+\phi(z')-\phi(x)-\phi(y)-\phi(z)  \\&= \phi(y')+\phi(z')-\phi(x)-\phi(y)\end{align}</script><p>但我们不具备一字型的放缩条件，我们需要换一种方法放缩，具体的，我们有$|y’|+|z’|+1 = |x’|$，采用相似的放缩方法，不难得到</p><script type="math/tex; mode=display">\phi(y')+\phi(z')-2\phi(x')<-1</script><p>那么我们有：</p><script type="math/tex; mode=display">\begin{align}1 + \Delta  \Phi(T) &= 1+\phi(y')+\phi(z')-\phi(x)-\phi(y)\\&< 1+\phi(y')+\phi(z')-\phi(x)-\phi(y) - (\phi(y')+\phi(z')-2\phi(x'))\\&=2\phi(x')-\phi(x)-\phi(y)\\&<2(\phi(x')-\phi(x))\end{align}</script><p>旋转结束后，总复杂度应小于$2(\phi(root)-\phi(x_0))&lt;2logn$</p><p>综上，加上先前单旋的时间复杂度，n个节点的splay树做m次旋转至根操作的时间复杂度为$O((n+m)logn)$，而对于查找和删除操作，所做的无非就是找到其前驱或者后继并用$O(1)$的操作更新根节点，复杂度不会超过$O(n)$，因此，对于插入和删除操作来说，总时间复杂度与上述结果相同，因此，m次操作的时间复杂度为$O((n+m)logn)$</p><h2 id="效率测试"><a href="#效率测试" class="headerlink" title="效率测试"></a>效率测试</h2><h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><p>Windows x86-64操作系统，处理器为11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz   3.00 GHz</p><p>评测环境采用LemonLine 0.3.4，相比c语言的clock函数，评测系统的测试结果更准确</p><h3 id="测例设计"><a href="#测例设计" class="headerlink" title="测例设计"></a>测例设计</h3><p>我一共尝试设计了五类测例：</p><ol><li><code>rand_data</code>：假设用户会随机的进行增删差操作，且增删差的值也是完全随机的。每组测例的操作指令数量均为200000，生成程序为<code>rand_data.cpp</code>。</li><li><code>qd_data</code>：这里试图模拟的环境是，用户在插入随机大小的数据时会随机地查询当前树内的元素，并且每次查到对应的元素后都将其取出，插入和查询的概率相等。每组测例的操作指令数量均为200000，生成程序为<code>qd_data.cpp</code>。</li><li><code>queue_data</code>：这里试图模拟一种队列式的数据操作，即控制树内总结点个数<code>window_size</code>不变，每次向其中添加一个新的结点，并删除最早插入的结点。每组测例的操作指令数量为200000，<code>window_size</code>为2000，生成程序为<code>queue_data.cpp</code>。</li><li><code>readonly_data</code>：只读类数据，即随机进行插入和查询两种操作，不删除树中结点，每组测例的操作指令数量为100000。生成程序为<code>readonly_data.cpp</code>。</li><li><code>local_data</code>：设计这个环境主要是为了模拟Splay树的使用环境，用户会以10%的概率做插入操作，并以5%的概率做删除操作，否则做查询操作，且在删除和查询时，如果上一次访问的元素没有被删除，则优先对该元素执行查询/删除操作，如果该元素已经被删除，则随机取元素删除/查询。每组测例的操作指令数量为200000。生成程序为<code>local_data.cpp</code>。</li></ol><p>对于上述数据中的每一类，我都生成了五组程序，分析时对运行时间取平均，这样可以有效降低实验中IO操作以及测试环境不稳定产生的误差。</p><p>此外，对于local类型数据，为了探究不同数据规模下两树的性能的差异，我取n = 50000，100000，200000，300000，400000，500000下，分别对两棵树的性能进行测试。</p><p>此外，我还写了<code>std.cpp</code>用来对每组输入数据生成正确的答案，命名为<code>&lt;类型&gt;.out</code>。</p><p>运行脚本<code>datamaker.bat</code>可以实现一组测例的生成，所有测例生成程序保存在<code>/datamaker</code>目录下</p><h3 id="测例生成器"><a href="#测例生成器" class="headerlink" title="测例生成器"></a>测例生成器</h3><p>测例生成器的思路就是使用c++标准库中的set来记录当前树中的所有结点，需要插入一个随机数时，不断生成随机数并查询该随机数是否在set中，直到找到一个不存在于set中的随机数，将该随机数插入set中，并输出插入信息。输出删除或查询操作时，通过<code>advance(it, rand() % data.size())</code>的方法实现随机选取set中的某个元素查询或删除。</p><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><ul><li>五种不同类型的数据在两棵树下的运行时间：</li></ul><div class="table-container"><table><thead><tr><th>类型</th><th>local</th><th>qd</th><th>queue</th><th>rand</th><th>readonly</th></tr></thead><tbody><tr><td><strong>Avl</strong></td><td>0.1216 s</td><td>0.1340 s</td><td>0.1556 s</td><td>0.1434 s</td><td>0.0778 s</td></tr><tr><td><strong>Splay</strong></td><td>0.1184 s</td><td>0.1556 s</td><td>0.1996 s</td><td>0.1558 s</td><td>0.1186 s</td></tr></tbody></table></div><ul><li>不同规模的local类型数据在两棵树下的运行时间：</li></ul><div class="table-container"><table><thead><tr><th>n</th><th>50000</th><th>100000</th><th>200000</th><th>300000</th><th>400000</th><th>500000</th></tr></thead><tbody><tr><td><strong>Avl</strong></td><td>0.031 s</td><td>0.062 s</td><td>0.125 s</td><td>0.187 s</td><td>0.265 s</td><td>0.328 s</td></tr><tr><td><strong>Splay</strong></td><td>0.062 s</td><td>0.062 s</td><td>0.125 s</td><td>0.171 s</td><td>0.281 s</td><td>0.312 s</td></tr></tbody></table></div><p>具体结果保存在<code>/result</code>目录下</p><h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><h4 id="总体结论"><a href="#总体结论" class="headerlink" title="总体结论"></a>总体结论</h4><p>多数情况下，Splay树的性能都落后于Avl树，而在少数有优势的情况下，这种优势又微弱到几乎可以忽略不计。</p><h4 id="结论及分析"><a href="#结论及分析" class="headerlink" title="结论及分析"></a>结论及分析</h4><h5 id="Splay树付出的额外时间用于旋转"><a href="#Splay树付出的额外时间用于旋转" class="headerlink" title="Splay树付出的额外时间用于旋转"></a>Splay树付出的额外时间用于旋转</h5><p>Splay树的复原需要用到<code>splay</code>操作，伸展操作需要将最后访问的结点旋转至根，尽管Avl树在一些特殊情况下也会出现多次旋转至根的情况（删除操作），但和Splay树任何操作都需旋转至根相比，Avl树的旋转次数还是要远远小于Splay树，而对于删除操作不是很多的数据（比如<code>readonly</code>类型），Avl在旋转次数上的优势会更加明显，这也就解释了相比其它数据类型，为什么<code>readonly</code>类型下Avl性能会比Splay性能快很多。</p><p>为了具体说明Splay树和Avl树在旋转次数上的差异，我又做了进一步的实验，对于前面生成的local类型数据，记录以这些数据为输入时，两棵树的旋转次数（即<code>zig</code>/<code>zag</code>函数的调用次数）</p><div class="table-container"><table><thead><tr><th></th><th>Splay旋转次数</th><th>Splay时间消耗(s)</th><th>Avl旋转次数</th><th>Avl时间消耗(s)</th></tr></thead><tbody><tr><td><strong>1</strong></td><td>500108</td><td>0.140</td><td>14219</td><td>0.109</td></tr><tr><td><strong>2</strong></td><td>497590</td><td>0.125</td><td>14082</td><td>0.109</td></tr><tr><td><strong>3</strong></td><td>495890</td><td>0.14</td><td>14290</td><td>0.14</td></tr><tr><td><strong>4</strong></td><td>493757</td><td>0.078</td><td>14152</td><td>0.125</td></tr><tr><td><strong>5</strong></td><td>489016</td><td>0.109</td><td>14067</td><td>0.125</td></tr></tbody></table></div><p>实验结果显示旋转次数上，Splay树和Avl树存在数量级上的差异，而Splay树相比Avl树运行更快的几组数据，也恰恰是Splay旋转次数和Avl旋转次数之比较小的几组。</p><p>Splay树的思想是通过额外的旋转将最近访问的结点旋转至树根，从而让局部数据的访问和操作更加便利，而在除了local类型的数据中，由于没有局部性条件，所以Splay付出额外旋转的成本并没有带来预期的收益，导致其效率不如Avl树。而在我设计的local类型数据中，Splay确实通过付出额外的旋转成本获得了查询时的高效，但这种高效并不十分惊艳。</p><h5 id="数据规模增大并不会使Splay树效率提升"><a href="#数据规模增大并不会使Splay树效率提升" class="headerlink" title="数据规模增大并不会使Splay树效率提升"></a>数据规模增大并不会使Splay树效率提升</h5><p>通过观察不同规模的local类型数据在两棵树下的运行时可以发现一些有趣的现象：在数据规模较小（n=50000）时，Splay树落于下风，而随着n的增大，Splay树开始显现出一定的优势，但这种优势并不像我们预期的那样随着n的增大而增大，同时它还具有一定的不稳定性（ n=400000时Avl树更优），不过对于为什么会产生这样的现象，还给不出很好的解释。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Avl和Splay树作为两种常见的平衡树，在操作数远大于树结点个数的前提下，大O记号分析表明其均摊时间效率相同，但在具体实验表现中，Av的整体表现是略优于Splay树的。事实上，在尝试构造测例的过程中，的确可以通过构造一些具有极端局部性的数据来让Splay体现优势，这说明Splay树的优势只有在一些特殊情况下才能体现出来，而就总体而言，Avl树对数据的敏感度更低，性能也更优。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DSA PA3 REPORT</title>
    <link href="/2023/01/16/DSA-PA3-REPORT/"/>
    <url>/2023/01/16/DSA-PA3-REPORT/</url>
    
    <content type="html"><![CDATA[<h1 id="CST-3-2-Report"><a href="#CST-3-2-Report" class="headerlink" title="CST 3-2 Report"></a>CST 3-2 Report</h1><h2 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h2><p><strong>位图数据结构设计：</strong>本题最大的限制是6MB的空间，也就是只提供 $6\times2^{20}$ B大小的空间，而字符串长度要求需要能存$2^{24}$个数的空间，这就意味着不能用传统的int数组或bool的方式来存，于是自然想到了上课介绍的位图数据结构，这种数据结构将每个01字符存储在了一个bit里。这样成功将存储空间压缩到了$2^{21}$B的大小，从而满足题目对空间的要求。具体来说，是通过char数组的方式，以每个字符存储8个01字符的方式存储该字符串。</p><p>此外，在查询固定长度的子串时，由于一个字符某一固定长度的子串个数和这个字符长度几乎相同（准确来说只相差了一个子串长度），为了记住查询结果，我们同样需要一个规模和字符串大小相同的01字符串，而这个字符串的存储又可以通过一个位图实例来实现。</p><p>因此，该算法用到了两个位图实例，第一个位图实例<code>b</code>负责存储字符串，第二个位图<code>found</code>负责存储针对某一特定位数，符合这种长度的01串是否出现在字符串中，具体来说，第 i 位存储的是原字符串中是否存在 i 二进制形式下的子串。</p><p><strong>针对某一特定长度k，查找是否存在NotFound子串:</strong> 在之前的位图设计中已经说明了<code>found</code>实例的含义，接下来还需要特别说明的是如何更高效的实现在原串中检索所有子串。首先，注意到如果线性扫描子串的话，每次扫到的子串和前一个子串相比只要首尾两个字符不同，这就意味着不用每次都把子串转化为十进制数，而是可以通过首尾数字对上一个子串对应的十进制数进行适当的运算转换成下一个子串对应的十进制数。此外，线性扫描时，设置<code>num</code>变量来记录发现了多少个不同的子串，可以稍稍提高之后寻找最小字典序的子串的效率。</p><p><strong>通过二分查找来优化搜索效率：</strong>由于字符串长度限制在$2^{24}$范围内，这就意味着，NotFound子串长度不能超过24，也就是说我们最终找到的这个NotFound子串长度确定在$[1,24]$内，而我们需要找的是满足在原串中找不到该子串，且该子串在所有NotFound子串中长度和字典序最小，于是便可以通过二分查找的方式优化时间效率。</p><p>具体来说，算法针对特定子串长度k，通过函数<code>see(k)</code>来判断是否存在NotFound子串，并在<code>res</code>中保存该所有该长度且不存在在原字符串的子串中字典序最小的那个，如果返回值为<code>true</code>，即找到了较小子串，下一次查找的范围就在<code>[lo,k)</code>之间，否则就在$[mid+1,hi)$之间（$lo和hi初始为1和25$）</p><h2 id="时间和空间复杂度的估算"><a href="#时间和空间复杂度的估算" class="headerlink" title="时间和空间复杂度的估算"></a>时间和空间复杂度的估算</h2><p><strong>时间复杂度：</strong>根据上一节对算法的描述，位图的赋值和循秩访问都是$O(1)$时间的，因此字符串读入时间为$O(n)$。此外，针对特定一子串长度的查询，需要多次线性扫描，因此时间复杂度为$O(n)$而子串长度在$[1,logn]$之间，通过二分查找优化，需要查找$O(log(logn))$次，因此总查询时长的时间复杂度为$O(nlog(logn))$。</p><p>综上，总时间复杂度为$O(nlog(logn)) n=2^{24}$</p><p><strong>空间复杂度：</strong>每个位图实例都需要开一个char数组，其大小正比于字符串长度，相比一个char存一个字符来说现在一个char可以存8个字符，空间复杂度为$O(n/8)$，消去常数后是$O(n)$，除此以外程序没有其它的大开销，因此总的空间复杂度就是$O(n)$</p><h1 id="CST-3-4-2-Report"><a href="#CST-3-4-2-Report" class="headerlink" title="CST 3-4-2 Report"></a>CST 3-4-2 Report</h1><h2 id="算法构思-1"><a href="#算法构思-1" class="headerlink" title="算法构思"></a>算法构思</h2><h4 id="线段树动态创建结点"><a href="#线段树动态创建结点" class="headerlink" title="线段树动态创建结点"></a>线段树动态创建结点</h4><p>根据提示，本题考察的是线段树这一数据结构，但由于n数据范围较大（$n&lt;2^{31})$，将完整线段树建出来所需要的空间成本过高（完整建出整棵树的空间复杂度是$O(n)$）。而另一方面，查询/插入区间操作的次数m比较有限（$m&lt;2\times 10^{5}$），实际上并不会真正用到每一个节点，尤其是一些靠近树叶的节点的信息，因此我们需要使线段树创立结点动态化，即不是在一开始就将线段树完整的建出来，而是”随用随建“，只有当操作需要读取/改变某个节点的儿子节点的信息时才将其儿子节点建立，从而起到减少空间占用的效果。</p><p>具体来说，如讲义634页所展示，每次翻盘/查询操作所访问到的节点可以构成一棵二叉树，而这棵二叉树又只有$O(log(n))$个叶节点（一个线段被分成两半，左半部分每层至多一个右子树作为叶节点，右半部分同理），根据二叉树性质，二叉树的非叶节点数=叶节点数-1,所以整个二叉树的节点个数也是$O(log(n))$的，因此m次操作，至多会访问到$O(mlog(n))$个节点，并不会访问所以节点。最终，根据本题数据范围和空间限制，我选择将存储节点的数组开到$10^6$大小。</p><h4 id="函数设计"><a href="#函数设计" class="headerlink" title="函数设计"></a>函数设计</h4><p><strong>懒惰标记：</strong>对于每一个节点，我为其设计了懒惰标记：懒惰标记lazy的值表示该节点表示的区间内，除了sum记录的翻牌次数外，该节点下的每个节点还会被翻lazy次，这样当翻盘时遇到某一结点表示的区间完全包含于操作区间时，只需要为其懒惰标记加1即可，而不需要递归其子树</p><p><strong><code>push_down</code>: </strong> 当操作需要访问某个节点的子节点时，首先需要尝试为其创建子节点，然后再将懒惰标记下放，并将该节点的sum值更新。</p><p><strong><code>merge_up</code>: </strong>用于翻牌操作，但对某节点的子节点进行翻牌操作后，此时子节点的sum变为修改后的值，需要根据左右子节点的sum值更新父节点的sum，从而使父节点sum值记录修改后的结果</p><p><strong>翻牌：</strong>用递归函数的方式实现，针对某一结点，对其$[l,r]$子区间进行翻牌操作，会有四种情况：1.$[l,r]$恰好就是这个节点表示的区间，则修改其懒惰标记后返回。2.$[l,r]$仅包含于左子树，则递归其左子树。3.$[l,r]$仅包含于右子树，则递归右子树。4.$[l,r]$既包含于左子树，又包含于右子树。对于后三种情况，需要同时递归两棵子树，并在递归后将两侧结果<code>merge_up</code>赋给父节点。</p><p><strong>查询：</strong>设计思路和翻牌类似，不同在于查询相当于”只读“，并不会真正修改sum的大小（但依然会有懒惰标记下放的情况，比如所查询的区间设计了新节点的建立），所以在情况1中只需要返回其sum值，而情况4中不再需要<code>merge</code></p><h4 id="常数优化"><a href="#常数优化" class="headerlink" title="常数优化"></a>常数优化</h4><p>为了将节点数组开的尽量大，我尽可能缩小了每个节点的大小，最后每个Node类只有3个int和1个long long，这样就可以使存储节点的数组开到$10^6$大小。</p><h2 id="时间和空间复杂度的估算-1"><a href="#时间和空间复杂度的估算-1" class="headerlink" title="时间和空间复杂度的估算"></a>时间和空间复杂度的估算</h2><p><strong>时间复杂度：</strong>如前文”线段树动态创建结点“一节所述，每次翻牌/查询操作，至多访问到$O(log(n))$个节点，而对每个节点操作的时间复杂度为$O(1)$，共进行m次这样的操作，所以总的时间复杂度为$O(mlog(n))$</p><p><strong>空间复杂度：</strong>如前文”线段树动态创建结点“一节所述，只需要$O(mlog(n))$个节点就可以满足m次操作访问节点的需求。而每个节点的空间复杂度为$O(1)$，因此总的空间复杂度为$O(mlog(n))$（在程序中我开到了$10^6$）</p><h1 id="CST-3-5-Report"><a href="#CST-3-5-Report" class="headerlink" title="CST 3-5 Report"></a>CST 3-5 Report</h1><p>做完 CST 3-6 最近邻查找后，本以为手握KD树模板，这道题会完成得比较快，但事实证明不同的问题中kdtree差异还是很大的，为此花了不少时间来改进原树模板。</p><h2 id="算法构思-2"><a href="#算法构思-2" class="headerlink" title="算法构思"></a>算法构思</h2><h4 id="KD-Tree构造方法"><a href="#KD-Tree构造方法" class="headerlink" title="KD-Tree构造方法"></a>KD-Tree构造方法</h4><h5 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h5><p>KD-Tree每个结点存储以下信息：</p><p><code>l</code>,<code>r</code>：左右孩子下标</p><p><code>num[2]</code>：该结点所表示点的坐标</p><p><code>dim</code>：该结点所“切”的维度，$dim\in[0,d)$</p><p><code>up_bond[2],low_bond[2]</code>：每一个结点都代表在2维空间的矩形中“切”了一刀，这两个数组表示的就是这个矩形的上下界。对于每一个结点点，我们规定其上下界为这个结点表示区域包含的所有结点的上下确界，特别的，如果只有一个结点，那么其上下确界就是自己的坐标。</p><p><code>max_temp,min_temp</code>:该结点表示区域内的最高气温和最低气温。</p><h5 id="建立KD-Tree"><a href="#建立KD-Tree" class="headerlink" title="建立KD-Tree"></a>建立KD-Tree</h5><p>原始结点被输入后存储在数组<code>node</code>中，我们用函数<code>build(lp,rp,d0)</code>递归地建立KD-Tree，对每一个递归实例：</p><ol><li>将<code>node</code>数组中下标处于$[lp,rp]$之间的部分进行升序排序，排序依据是其第d0维的坐标大小($d0=0 , 1$)</li><li>对区间进行线性扫描，确定空间坐标的上下确界，更新<code>up_bond[2],low_bond[2]</code></li><li>找到排序后区间内中位数的结点，用该结点的坐标来构造一个KD-Tree中的结点，并将该结点保存在<code>kdtree[index]</code>中</li><li>递归$[lp,rp]$的左半部分和右半部分（构造时需要判定左右区间是否为空，如果为空则不需要再为其建立子结点，此时其子结点下标指向0，也可视作空结点或垃圾结点），递归构造<code>kdtree[index]</code>的左右子树，最后更新其区域内温度最大值和最小值。</li></ol><p><strong>区间内的温度最值查找：</strong></p><p>我们设计了<code>query_p</code>函数来递归地查找结点p表示的区域和给定查找区间的交集，并更新查找到的气温最大值和最小值，对于每个结点分为以下四种情况讨论：</p><ol><li>到达空结点，则直接返回，不做更新操作</li><li>结点表示区域包含于查找区间，则直接根据这个结点标记的气温最大值和最小值更新查找结果，不需要再深探</li><li>结点表示区域与查找区间完全无交集，则直接返回不做更新操作</li><li>结点表示区域与查找区域存在交集，则首先根据这个结点表示站点的温度最大值和最小值更新查找结果，然后对其左右子树进行深探。</li></ol><p>在实际写代码的时候，我们采取比较两个维度来确定查找区间和结点区间的关系，这是和讲义中KD树区间查询不同的地方，但显然这个剪枝要比比较单维度更强，实际运行的时候效果也更好。</p><h2 id="时间和空间复杂度的估算-2"><a href="#时间和空间复杂度的估算-2" class="headerlink" title="时间和空间复杂度的估算"></a>时间和空间复杂度的估算</h2><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>本题的时间消耗来自两步操作：建立KD-Tree和对KD-Tree的查找，下面分别对其进行分析。</p><p>建立KD-Tree的时间复杂度可以这样分析：考虑一颗满树，其深度为k的层有$2^k$个结点，也就对应在递归建立是要创建$2^k$个递归实例，对于每一个递归实例，其包含的区间长度为$len \leq \frac {n}{2^{k}}$，每一个递归实例中，时间复杂度主要来自区间排序，其复杂度为$O(lenlog(len))$而每一层总的时间复杂度应为$O(lenlog(len) \cdot 2^k) = O(n(logn-k)) k=1,2,… logn$。KD-Tree共有$logn$层，因此总的时间复杂度为$O(n(logn)^2)$。</p><p>对KD-Tree的每次区间查找，根据讲义中对KD树查询的时间复杂度分析，由于每两刀最多切到2个矩形，因此复杂度递推式满足$Q(n)=2Q(n/4)+O(1)$，因此其复杂度为$O(\sqrt n)$（讲义中的问题是记录具体的所有点，因此还要加上report的复杂度r，但本题只获取区间最值，更新次数应正比于区间包含的矩形框个数，对于完全包含于区间的矩形框，不需要深究其内部的每个点，因而不需要加r）。</p><p>综上，结合这两步操作，总的时间复杂度为$O(n(logn)^2+m\sqrt n)$</p><h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><p>KD-Tree存储在数组<code>kdtree</code>中，每个结点的struct需要存储12个int，数组空间消耗为$O(n)$，原始结点存储在二维<code>node</code>数组中，其大小也为$O(n)$，建树的递归实例个数应等于KD树的结点个数，节点个数不大于2n，递归建树空间复杂度为$O(n)$，查询递归的递归实例个数应等于访问结点的个数$O(log(n))$。</p><p>因此，总的空间复杂度为$O(n+log(n)) = O(n)$</p><h1 id="CST-3-6-Report"><a href="#CST-3-6-Report" class="headerlink" title="CST 3-6 Report"></a>CST 3-6 Report</h1><h2 id="算法构思-3"><a href="#算法构思-3" class="headerlink" title="算法构思"></a>算法构思</h2><h4 id="KD-Tree构造方法-1"><a href="#KD-Tree构造方法-1" class="headerlink" title="KD-Tree构造方法"></a>KD-Tree构造方法</h4><h5 id="结点-1"><a href="#结点-1" class="headerlink" title="结点"></a>结点</h5><p>KD-Tree每个结点存储以下信息：</p><p><code>l</code>,<code>r</code>：左右孩子下标</p><p><code>num[5]</code>：该结点所表示点的坐标</p><p><code>dim</code>：该结点所“切”的维度，$dim\in[0,d)$</p><p><code>up_bond[5],low_bond[5]</code>：每一个结点都代表在d维空间($2\leq d \leq5$)的高维立方体中“切”了一刀，这两个数组表示的就是这个“<strong>高维立方体</strong>”的上下界。对于根节点，我们将其上下界设为$\pm MAX$，其大小为$10^7$(因为题目规定每一个向量坐标不会超过这一区域，所以MAX起到代替$\infty$的作用)</p><p>为每个结点设置上下界的目的是，在查找最近邻时，能通过查询结点到某个一个结点所处的空间立方体的距离，判断是否需要剪枝（query节中进一步介绍）</p><h5 id="建立KD-Tree-1"><a href="#建立KD-Tree-1" class="headerlink" title="建立KD-Tree"></a>建立KD-Tree</h5><p>原始结点被输入后存储在数组<code>node</code>中，我们用函数<code>build(lp,rp,d0)</code>递归地建立KD-Tree，对每一个递归实例：</p><ol><li>将<code>node</code>数组中下标处于$[lp,rp]$之间的部分进行升序排序，排序依据是其第d0维的坐标大小</li><li>找到排序后区间内中位数的结点，用该结点的坐标来构造一个KD-Tree中的结点，并将该结点保存在<code>kdtree[index]</code>中</li><li>递归$[lp,rp]$的左半部分和右半部分（构造时需要判定左右区间是否为空，如果为空则不需要再为其建立子结点，此时其子结点下标指向0，也可视作空结点或垃圾结点），构造<code>kdtree[index]</code>的左右子树，同时更新其对应区域的上下界。</li></ol><p><strong>查找最近邻结点：</strong></p><p>每次查找某个结点q的最近邻时，用<code>min_len</code>记录最短距离，首先在KD-Tree中不断深探找到“离q最近”的叶节点，但这个“离q最近”是打引号的，正如KD-Tree的区间查找算法一样，由于每个结点的具体位置并不确定，所以深探找到的叶节点未必就是真正离q最近的结点。此时需要自下而上班地回溯深探过程中经过的所有结点，对于每一个路径上的非叶结点，首先应判断此结点<strong>距离q是否更近</strong>并更新<code>min_len</code>。此外，如果该结点的另一棵子树可能存在一个距离q比当前最短距离更短的结点。则需要对另一棵子树进行搜索，重复此操作，直至回溯至根节点。</p><p>那么如何判定一个结点的另一棵子树是否可能存在距离q最近的结点呢？我们给出两种剪枝方法：</p><ol><li>判断该结点对应的维度上，结点和q距离的平方是否小于<code>min_len</code>，实际上这一操作是求了q到这一边界的垂直距离，若小于，则需要搜索另一子树。</li><li>判断该结点另一个儿子对应的“高维立方体”p和q的距离，运算公式为$\Sigma_{i=0}^{d-1}(len(q,p,i))^2$，其中$len(q,p,i)$表示在第i维上q到高维立方体p的距离，显然当$q[i]\in[p.low_bond[i],p.up_bond[i]]$时，该维度的距离为0。若这一距离小于了<code>min_len</code>则有必要对其进行深探。</li></ol><p>显然第一种剪枝方法是弱于第二种剪枝方法的，但程序中实际上同时用了两种剪枝方法，原因是计算多维距离的平方这一操作虽然能够跟多的剪枝，但计算本身却要花费比方法一更多的时间。因此，我们采用了先用方法一粗判剪枝，再用方法二进一步细判的方法，提高剪枝效率。</p><h2 id="时间和空间复杂度的估算-3"><a href="#时间和空间复杂度的估算-3" class="headerlink" title="时间和空间复杂度的估算"></a>时间和空间复杂度的估算</h2><h5 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>本题的时间消耗来自两步操作：建立KD-Tree和对KD-Tree的查找，下面分别对其进行分析。</p><p>建立KD-Tree的时间复杂度可以这样分析：考虑一颗满树，其深度为k的层有$2^k$个结点，也就对应在递归建立是要创建$2^k$个递归实例，对于每一个递归实例，其包含的区间长度为$len \leq \frac {n}{2^{k}}$，每一个递归实例中，时间复杂度主要来自区间排序，其复杂度为$O(lenlog(len))$而每一层总的时间复杂度应为$O(lenlog(len) \cdot 2^k) = O(n(logn-k)) k=1,2,… logn$。KD-Tree共有$logn$层，因此总的时间复杂度为$O(n(logn)^2)$。</p><p>对KD-Tree的每次查找，上网查询得知在点随机均匀分布的情况下其时间复杂度为$O(logn)$，但因为个人能力有限，无法对一般情况进行证明，下面仅在一个特别情况，即所有点都严格均匀分布的情况下证明其复杂度。</p><p>可以这样考虑，对KD-Tree的每次查找，首先要深探至叶节点，其复杂度为$O(logn)$，将整个d维空间平均划分为边长为$\frac{a}{n^{1/d}}$的n个d维立方体，由于每个向量分布是均匀的，因此每个立方体内仅存在结点，深探所确定的叶结点与目标结点q之间的的距离，应不大于d维立方体体对角线的长度$L = \sqrt d\cdot a\cdot n^{-1/d}$，因为高维球体体积不太方便计算，下面考虑以$2L$为边长，q为中心做高维立方体$M$，球真包含于该立方体中，任何在该立方体之外的高维立方体和q的距离应大于$L$，而根据此前对每个立方体内结点只有1个的条件，$M$内所包含的结点个数肯定不会超过$2^dd^{d/2}$，因此获取他们中长度最小值的时间复杂度为$O(2^dd^{d/2})$，由于$d\leq5$，可以认为这个复杂度是$O(1)$的</p><p>因此，对于q次查找，其时间复杂度为$O(q(logn))$</p><p>因此，总的时间复杂度为$O(n(logn)^2+qlogn) \ n \leq 10^5, q \leq 2 \cdot10^5 \ d\leq5, \ n \leq 10^5, q \leq 2 \cdot10^5$</p><p><strong>空间复杂度</strong></p><p>KD-Tree存储在数组<code>kdtree</code>中，每个结点的struct需要存储18个int，因此其空间消耗为$O(18n)$，原始结点存储在<code>node</code>数组中，其大小也为$O(5n)$，除此以外，建树的递归实例个数应等于kd树的结点个数，节点个数不大于2n，查询递归的递归实例个数应等于访问结点的个数，递归深度为$O(log(n))$。因此总的空间复杂度应该为$O(n+log(n)) = O(n)$</p><h1 id="LAB2-HashFun-Report"><a href="#LAB2-HashFun-Report" class="headerlink" title="LAB2 HashFun Report"></a>LAB2 HashFun Report</h1><h3 id="不同哈希策略的实现"><a href="#不同哈希策略的实现" class="headerlink" title="不同哈希策略的实现"></a><strong>不同哈希策略的实现</strong></h3><p><strong>“坏”哈希函数：</strong>将每个字符的ascii值相加求和后对N取模。</p><script type="math/tex; mode=display">res = {\sum_{i=0}^{strlen(str)}{str[i]}}  \ \%N</script><p><strong>“好”哈希函数：</strong>将字符串根据ascii码值视作128进制数，将其转化为十进制后对N取模，和坏的哈希函数相比，这一函数能区分相同字符通过不同顺序组成的单词，因此更加均匀。</p><script type="math/tex; mode=display">res = {\sum_{i=0}^{strlen(str)}{str[i]}\cdot 128^i}  \ \%N</script><p><strong>双向平方试探策略：</strong>先通过哈希函数为字符串确定一个初始值(<code>init</code>中实现)，然后以该位置为轴双向平方试探。在派生类中定义变量成员<code>stride</code>记录上一次试探步长，每次试探更新stride，并根据变化前后stride确定新位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> old_stride = stride;<br>    <span class="hljs-keyword">if</span> (stride &lt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//向右试探</span><br>        stride = -stride + <span class="hljs-number">1</span>; <br>        <span class="hljs-type">int</span> next = ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)old_stride * old_stride) % table_size;<br>        next = (next + (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)stride * stride) % table_size;<br>        <span class="hljs-keyword">return</span> (last_choice + next) % table_size;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//向左试探</span><br>        stride = -stride;<br>        <span class="hljs-type">int</span> next = ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)old_stride * old_stride) % table_size;<br>        next = (next + (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)stride * stride) % table_size;<br>        <span class="hljs-keyword">return</span> (last_choice - next + table_size) % table_size;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>公共溢出区策略：</strong></p><p>原有<code>table_size</code>拿出一半设为缓冲溢出区，在<code>hashtable</code>构造函数中用向下转换判断冲突类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">overflow_probe* find = <span class="hljs-built_in">dynamic_cast</span>&lt;overflow_probe*&gt;(my_collision);<span class="hljs-comment">//相下转换，如果成功则是公共溢出策略</span><br><span class="hljs-keyword">if</span> (find) &#123;<br>    table_size =  size/<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>每次探测时，从<code>table_size</code>（溢出区起点）向后扫描</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (last_choice &lt; table_size)<br>    <span class="hljs-keyword">return</span> table_size;<br><span class="hljs-keyword">return</span> last_choice + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a><strong>测试数据</strong></h3><p><strong>构造方法：</strong>从<code>poj.txt</code>中提取所有信息，对其使用<code>random_shuffle</code>混排取前<code>in_num</code>项。数据生成有三个参数：</p><ul><li><code>in_num</code>：插入的字符串数量，字符串选取方法见上</li><li><code>sear_num</code>：询问次数，其中一半为成功查找，一半为失败查找，失败询问构造方法为<code>“#_#”+存在的字符串</code>，正确和失败查找交替出现</li><li>第三个参数为1时，将插入的键值字符串按字典序升序排序，否则不排序</li></ul><p>运行<code>makedata.bat</code>脚本可生成对应的数据</p><p><strong>数据特征：</strong>（表大小为200023）</p><div class="table-container"><table><thead><tr><th></th><th>in_num</th><th>sear_num</th><th>是否排序</th></tr></thead><tbody><tr><td>0</td><td>10000</td><td>8000</td><td>否</td></tr><tr><td>1</td><td>10000</td><td>8000</td><td>是</td></tr><tr><td>2</td><td>100000</td><td>80000</td><td>否</td></tr></tbody></table></div><ul><li>数据0和数据1相比，数据规模相同（但两次随机取，内容不完全一致），区别在于是否排序</li><li>数据2和数据0相比，数据规模扩大了10倍</li></ul><p>运行<code>run.bat</code>进行一组测试，运行的具体结果保存在result0,1,2三个文件夹下。</p><h3 id="分析结果"><a href="#分析结果" class="headerlink" title="分析结果"></a><strong>分析结果</strong></h3><ol><li>无论规模如何，插入值排序与否，<strong>好哈希都明显提高程序性能</strong>（最好300倍），因为好哈希让散列更均匀，减少冲突次数，排序对运行效率无明显影响。</li><li><strong>双向平放和线性试探相比，散列不均匀性能提升明显，均匀时无提升</strong>。可能是不均匀时，双向平方试探可迅速跳出聚集点。而散列均匀时，线性试探也能在附近迅速找到空位。</li><li><strong>不均匀散列，开放和封闭效率大体相同，均匀散列，封闭表现明显更优</strong>。另外装填因子较大时，封闭散列明显更占优。公共溢出区策略在处理表的局部比较“满”，再插入少量数据的情况下，可能表现更好。</li><li>字符串本身不均匀，可能导致“好”哈希函数生成的散列也不均匀，冲突增多。</li><li>可以记录实时的装填因子，对不同哈希策略，实验确定装填因子为多大时扩容或者缩容，使性能最优。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DSA PA2 REPORT</title>
    <link href="/2023/01/16/DSA-PA2-REPORT/"/>
    <url>/2023/01/16/DSA-PA2-REPORT/</url>
    
    <content type="html"><![CDATA[<h1 id="2-1-Risk-Report"><a href="#2-1-Risk-Report" class="headerlink" title="2-1 Risk Report"></a>2-1 Risk Report</h1><h2 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h2><p>本题的核心是如何构造一个类似于“队列”的数据结构，数据遵循先进先出的原则，且又能在O(1)时间内找到最大值。针对本题，我发现从$i−m_i$到$i-1$并不是每一个数字都有意义，实际上，只需要存储这样一个子序列就可以：<strong>该子序列B满足子列的每一项都严格大于所有原数组中项数大于这一项的元素</strong>，而每当 i 加一，只需要根据$m_i$删掉B的前几项，并从子序列的最后开始向前找到大于A[i-1]的项并删掉其后面的所有元素，这样就可以得到新的满足要求的B。</p><p>在搜索满足最大确诊病例在[0,p),[p,q)问题上，我采取了维护前缀和的方法，即<code>les_num[i]</code>表示最大确诊病例数小于 i 的总天数</p><h2 id="时间和空间复杂度的估算"><a href="#时间和空间复杂度的估算" class="headerlink" title="时间和空间复杂度的估算"></a>时间和空间复杂度的估算</h2><p><strong>时间复杂度：</strong>注意到维护B序列的两个指针lo和hi一定最多只会扫过一个一个元素一次，所以维护B序列的时间复杂度为$O(n)$，此外维护前缀和数组的时间复杂度为$O(m) \, m=2*10^{6}$，查询时间复杂度为$O(T)$。因此总复杂度为$O(m+n+T)$</p><p><strong>空间复杂度：</strong>程序开了三个长为n的数组，分别存储每日病例数，B数组每一项对应的病例数和B数组元素在原数组的下标。此外还开了两个长为m的数组存储每日前$i-m_i$日最大病例数和前缀和。总空间复杂度为$O(n+m)$</p><h1 id="CST-2-2-Report"><a href="#CST-2-2-Report" class="headerlink" title="CST 2-2 Report"></a>CST 2-2 Report</h1><h2 id="算法构思-1"><a href="#算法构思-1" class="headerlink" title="算法构思"></a>算法构思</h2><p>本题的实现思路主要参考教材中中缀表达式的算法。大体思想为：从左向右依次扫描一个每个字符，如果读到的是操作数则加入操作数栈，如果是操作符则需要比较和操作符栈栈顶的优先级关系，如果栈顶优先级更高则计算栈中两个操作数（本题中除括号外全部都是双目运算符），如果当前操作符优先级更高则入栈，如果相当则去掉栈顶操作符，并读取下一个位置的字符（对应去括号和\0匹配）。</p><p>为了完成本题我构造了两个类，<code>Stack</code>和<code>Poly</code>，前者用数组模拟了一个简单的栈结构，后者建立了一个多项式类实现其各项系数的存储以及加减乘次方运算。</p><p>具体实现时本题和教材也有一些不同：</p><ol><li>本题中操作数是一位位读入，且含有x，因此我设置了<code>tmp_num</code>变量来记录多位数，并且考虑x的情况。只有当读入下一个字符时才能知道之前的操作数读入是否结束，此时才将此前的操作数转化成Poly对象后入栈，这也是和教材不太一样的地方。</li><li>乘号省略。根据题目描述，乘号省略包括“)(，n(，x(，nx，)x”（n表示数字）这5种情况，所以每次读入字符时会判断一下这个字符和其前一个字符是否满足乘号省略的条件，如果满足则相当于先要让乘法和栈顶操作符比较，运算或入栈后再次读取当前字符（我使用一个<code>mul</code>变量来记录“读入当前字符时是否已经考虑乘号被省略”，从而确定是补乘号还是真正读取当前字符）</li><li>取模运算，每次运算后都要对1000000007取模，对于负数x，我采用$(x+1000000007)\mod1000000007$的方法</li></ol><p>一些算法优化：</p><ol><li>在读入字符串时，考虑到\^1这个运算本身对运算结果没有影响，为了避免不必要的次方运算，省略了所有\^1</li><li>每当构造一个多项式类时，都会用一个<code>_degree</code>变量来记录这个多项式类实例的最高位幂次，这样在乘法运算时不需要循环64*64次而只需要循环<code>_degree1</code>*<code>_degree2</code>次</li></ol><h2 id="时间和空间复杂度的估算-1"><a href="#时间和空间复杂度的估算-1" class="headerlink" title="时间和空间复杂度的估算"></a>时间和空间复杂度的估算</h2><p><strong>时间复杂度：</strong>程序时间复杂度主要来自三部分：字符串读入和出入栈计算。字符串读入显然是$O(n)$的，下面针对出入栈计算的时间复杂度进行分析。</p><p>每当扫描到一个字符，程序会判断此时运算数入栈（这里的运算数实际上是这个字符之前的字符组成的，比如123*x当扫描到*时123入栈）、运算符入栈或继续扫描，这个判断是线性的。计算时程序开了运算数和运算符两个栈，字符串中每个字符至多入其中一个栈一次并出栈一次（考虑到有些字符会整体作为一个数字入运算数栈，实际上出入栈的是运算数和运算符，其总和是小于字符串长度的）。此外，考虑到乘号省略情况，补全乘号后的字符串总长度也一定不会超过2n，最坏情况下也是线性的。运算数和运算符出栈时进行计算，每次计算的复杂的为常数次，因此总复杂度可以视作为 $O(n)$</p><p>综上所述，算法的时间复杂度为$O(n)$</p><p><strong>空间复杂度：</strong>每个栈均需开一个长为1000010的数组，共开两个栈，运算符栈每个元素的大小为char类型大小，运算数栈每个元素为一个Poly类，每个Poly类实例占空间大小主要为长为65的int数组，因此两个栈空间复杂度都可以视为$O(n)$。此外程序还开了一个长为1000010的字符串来存储中缀表达式。因此总空间复杂度为 $O(n)$</p><h1 id="LAB1-Zuma-Report"><a href="#LAB1-Zuma-Report" class="headerlink" title="LAB1 Zuma Report"></a>LAB1 Zuma Report</h1><h2 id="01"><a href="#01" class="headerlink" title="01"></a>01</h2><p><strong>错误类型</strong></p><p>Runtime Error</p><p><strong>错误原因</strong></p><p>第19行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">play</span>(left - <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>未考虑到如果left本身变为0的时候left-1小于0的情况，即某种操作使从最首字符开始到操作位置之间的字符都被消掉，即会触发该错误</p><p><strong>测例构造</strong></p><p>相应测例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">AABBAB<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span> <span class="hljs-selector-tag">B</span><br></code></pre></td></tr></table></figure><p>标准答案：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">B</span><br></code></pre></td></tr></table></figure><p>构造思路：只需要构造某种操作使从首字符开始到操作位置之间的字符都被消掉的情况即可。上例中，当执行第一次消除后，程序运行到第19行时<code>left=0</code>此时会调用函数<code>play(- 1)</code>，而执行到第十行<code>a.at(rank);</code>此时<code>rank=-1</code>会导致函数访问数组错误，导致RE。</p><h2 id="02"><a href="#02" class="headerlink" title="02"></a>02</h2><p><strong>错误类型</strong></p><p>Runtime Error</p><p><strong>错误原因</strong></p><p>未考虑到字符串被消除为空串后<code>a.at(0)</code>会越界访问</p><p><strong>测例构造</strong></p><p>相应测例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">AABBAA<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span> <span class="hljs-selector-tag">B</span><br></code></pre></td></tr></table></figure><p>标准答案：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">（空串）<br></code></pre></td></tr></table></figure><p>构造思路：只需要构造某种操作使字符完全被消除，得到空串即可。此时完全消除字符串后变量<code>next</code>=0，函数调用<code>play(0)</code>，在下一个实例中，第十行调用<code>at(0)</code>时会导致数组越界访问</p><h2 id="03"><a href="#03" class="headerlink" title="03"></a>03</h2><p><strong>错误类型</strong></p><p>Time Limit Exceeded</p><p><strong>错误原因</strong></p><p>该算法中用到的<code>erase</code>和<code>insert</code>方法的时间复杂度均是$O(n)$，最坏情况下，整体复杂度为$O(mn)$，效率过低会导致超时问题</p><p><strong>测例构造</strong></p><p>相应测例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">AABBCCDDEEFFGGHHIIJJKKLLMMNNOOQQPPRRSSTTUUVVWWXXYYZZ……<br><span class="hljs-number">500000</span><br><span class="hljs-number">0</span> <span class="hljs-selector-tag">A</span><br><span class="hljs-number">0</span> <span class="hljs-selector-tag">B</span><br>……<br></code></pre></td></tr></table></figure><p>标准答案：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">UUVVWWXXYYZZAABBCC……<br></code></pre></td></tr></table></figure><p>构造思路：使n和m均达到数据大小上限，并且每一次操作都有一定的复杂度（比如让每次操作都消除一些字符串）便会导致超时。</p><h2 id="04"><a href="#04" class="headerlink" title="04"></a>04</h2><p><strong>错误类型</strong></p><p>Wrong Answer</p><p><strong>错误原因</strong></p><p>代码第12行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (left &gt; <span class="hljs-number">0</span> &amp;&amp; a.<span class="hljs-built_in">at</span>(left) == color) --left;<br></code></pre></td></tr></table></figure><p>操作时由于left未加1导致每次删除的字符串左侧会多删除一个，因此导致错误结果</p><p><strong>测例构造</strong></p><p>相应测例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">ABBC<br><span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-selector-tag">B</span><br></code></pre></td></tr></table></figure><p>标准答案：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">AC</span><br></code></pre></td></tr></table></figure><p>构造思路：构造一个待删除串左侧有不应该被删除的字符即可，上例中A就会被错误删除，消除时left=0，right=3，则<code>erase(left, size)</code>会删除字符串ABB，导致WA。</p><h2 id="05"><a href="#05" class="headerlink" title="05"></a>05</h2><p><strong>错误类型</strong></p><p>Wrong Answer</p><p><strong>错误原因</strong></p><p>代码第27行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cin &gt;&gt; a;<br></code></pre></td></tr></table></figure><p>输入字符串时用的<code>cin</code>而非<code>getline</code>，无法读入空字符串，不满足输入要求</p><p><strong>测例构造</strong></p><p>相应测例：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span>A<br></code></pre></td></tr></table></figure><p>标准答案：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span><br></code></pre></td></tr></table></figure><p>构造思路：构造一个空串即可制造错误，<code>cin&gt;&gt;a</code>无法读入。</p><h2 id="06"><a href="#06" class="headerlink" title="06"></a>06</h2><p><strong>错误类型</strong></p><p>Wrong Answer</p><p><strong>错误原因</strong></p><p>当某一块输入大于$2^{12}$时，程序没有进行重组块操作，溢出的数据可能覆盖后面的块</p><p><strong>测例构造</strong></p><p>相应测例：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ</span>……<br><span class="hljs-number">2049</span><br><span class="hljs-number">1</span> <span class="hljs-variable">A</span><br><span class="hljs-number">1</span> <span class="hljs-variable">B</span><br><span class="hljs-number">1</span> <span class="hljs-built_in">C</span><br><span class="hljs-number">1</span> <span class="hljs-built_in">D</span><br><span class="hljs-number">1</span> <span class="hljs-built_in">E</span><br><span class="hljs-number">1</span> <span class="hljs-variable">F</span><br><span class="hljs-number">1</span> <span class="hljs-variable">G</span><br><span class="hljs-number">1</span> <span class="hljs-variable">H</span><br>……<br></code></pre></td></tr></table></figure><p>标准答案：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">AUTSRQPONMLKJIHGFEDCBA……<br></code></pre></td></tr></table></figure><p>构造思路：构造一个使某一块长度大于$2^{12}$的操作即可使块数据溢出，上例中，会不断向位置1处添加字符且不会发生消除，在添加$2^{11}$个后，<code>p[0]</code>中元素已满，此时再在第0块中添加一个字符且不可消去时，<code>p[0]</code>溢出覆盖后面的内存，导致错误结果</p><h2 id="07"><a href="#07" class="headerlink" title="07"></a>07</h2><p><strong>错误类型</strong></p><p>Wrong Answer</p><p><strong>错误原因</strong></p><p>第96行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (l.second &lt; <span class="hljs-number">0</span> &amp;&amp; l.first &gt;= <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>应改为while循环，否则会导致当某次消除需要跳过一个已经为空的块儿时无法跳过（if仅使<code>l.first</code>减了一次）</p><p><strong>测例构造</strong></p><p>相应测例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">CAABBAABB……AAD（第一块）AABB……AABB （第二块）DE<br><span class="hljs-number">2048</span><br><span class="hljs-number">1</span> A<br><span class="hljs-number">1</span> B<br><span class="hljs-number">1</span> A<br><span class="hljs-number">1</span> B<br>……<br><span class="hljs-number">2</span> A<br><span class="hljs-number">2</span> B<br><span class="hljs-number">2</span> A<br><span class="hljs-number">2</span> B<br>……<br><span class="hljs-number">2</span> D<br></code></pre></td></tr></table></figure><p>标准答案：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">CE</span><br></code></pre></td></tr></table></figure><p>构造思路：构造一个消除操作恰好要越过一个空块儿的测例即可，算法无法越过空快向前读取重复的字符，比如上例中，在最后一个D输入前，字符串会消除为“CD(第一块)（第二块为空）DE（第三块），此时在2处插入D，此时执行第96行时，程序无法从第三块跨过第二块看到第一块中的D，从而无法将D连消，导致产生CDDDE这样的错误结果</p><h2 id="08"><a href="#08" class="headerlink" title="08"></a>08</h2><p><strong>错误类型</strong></p><p>Wrong Answer</p><p><strong>错误原因</strong></p><p>第92行处未进行while(1)操作，会导致无法连续消除</p><p><strong>测例构造</strong></p><p>相应测例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">AABBAA<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span> B<br></code></pre></td></tr></table></figure><p>标准答案：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">（空串）<br></code></pre></td></tr></table></figure><p>构造思路：构造一个会发生连续消除的样例即可</p><h2 id="09"><a href="#09" class="headerlink" title="09"></a>09</h2><p><strong>错误类型</strong></p><p>Runtime Error</p><p><strong>错误原因</strong></p><p>第130行处未判定<code>l.first</code>和<code>r.first</code>是否相等，可能出现两个相等即删除的字符串但没有跨越块儿的情况，这时候plen可能会记录错误的块长度大小数据，从而在<code>p2a</code>函数中<code>memcpy</code>函数移动数组时产生访问越界的问题</p><p><strong>测例构造</strong></p><p>相应测例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">AABBCC<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span> B<br></code></pre></td></tr></table></figure><p>标准答案：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">AACC</span><br></code></pre></td></tr></table></figure><p>构造思路：构造一个消除只发生在一个块内，且消除字符串的前后都有需要被保留的字符串即可，这样就会导致plen记录了错误的长度大小（负值），本例中，<code>l.second</code>=1,<code>r.seconde</code>=5,由于<code>l.first</code>与<code>r.first</code>相等，因此第135行计算出的<code>len</code>为-3，而赋到<code>size_t</code>类型的plen[0]中时会被转换成大整数18446744073709551613这样一个很大很大的数，远远大于p[i]的大小（$2^{12}$），导致在函数<code>p2a</code>中执行 <code>memcpy</code>时，将一个取了大于p[i]大小的数组内容，这就产生了了数组越界。</p><h2 id="10"><a href="#10" class="headerlink" title="10"></a>10</h2><p><strong>错误类型</strong></p><p>Wrong Answer</p><p><strong>错误原因</strong></p><p>第147行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l.first; i &lt; r.first; i++)<br>    plen[i] = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>i从<code>l.first</code>开始，并将其长度置为0，实际上第i块长度并不一定达到零，这就会导致最后在<code>p2a</code>组装回去中各块出现长度不对应的情况，在a长度计算正确的情况下，会导致组装错误</p><p><strong>测例构造</strong></p><p>相应测例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">BAABBAABB……AABBC<br><span class="hljs-number">1</span><br><span class="hljs-number">2048</span> B<br></code></pre></td></tr></table></figure><p>标准答案：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">BAABBAABB……AAC<br></code></pre></td></tr></table></figure><p>构造思路：构造一个消除会跨越块发生，且消除字符的前后都有剩余字符的测例即可。本例中，数组总长计算没有错，但<code>plen[0]</code>会被赋成0，所以导致<code>p2a</code>中第一块部分并没有被组装回原数组a中，只有<code>p[1]</code>中剩余的“C”会被复制到a[0]开始的内存中，而后面的部分实际上是a数组原来的剩余，最终导致输出C（来自<code>p[1]</code>）AABBAABB……（原数组剩余）的结果，产生错误答案</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DSA PA1 REPORT</title>
    <link href="/2023/01/15/DSA-PA1-REPORT/"/>
    <url>/2023/01/15/DSA-PA1-REPORT/</url>
    
    <content type="html"><![CDATA[<h1 id="CST-1-2-Graphics-Report"><a href="#CST-1-2-Graphics-Report" class="headerlink" title="CST 1-2 Graphics Report"></a>CST 1-2 Graphics Report</h1><h2 id="算法构思"><a href="#算法构思" class="headerlink" title="算法构思"></a>算法构思</h2><p>交点的个数问题可以转化成该点所在区域（考虑到没有线段相交这个条件）即可，因此此算法实现分为两步：对x、y点的排序以确定每条线段和查找确定点所在的区域。</p><p>排序实现参考了课本中的归并排序算法来实现，不同处在于一次实现了x和y两个数组的排序（两个数组大小一样所以每次划分的左右两段长度也一样，可以在一个函数中实现）</p><p>查找时基于二分查找的思路，确定点的区域时每次比较时利用了叉乘进行判断，从而避免出现除法，考虑到数据范围会超出int，判断时使用long long数据类型，同时还需考虑边界情况（位于最左侧线段的左侧和最右侧线段的右侧）</p><h2 id="时间和空间复杂度的估算"><a href="#时间和空间复杂度的估算" class="headerlink" title="时间和空间复杂度的估算"></a>时间和空间复杂度的估算</h2><p><strong>时间复杂度：</strong>归并排序算法复杂度为 $O(nlogn)$，二分查找每次算法复杂度为 $    O( log (n) ) $ ，总复杂度为 $O((n+m)logn)$</p><p><strong>空间复杂度：</strong>全局变量<code>x_0</code>和<code>y_0</code>存储了坐标轴上的点的信息，占用空间为2n，归并排序每次合并时新开了<code>x_1</code>和<code>y_1</code>数组，合并后会立即删除，不会保留到之后的合并中，占用空间为2n，二分查找本身不占用空间，因此总空间占用为$O(n)$</p><h1 id="CST-1-3-filename-Report"><a href="#CST-1-3-filename-Report" class="headerlink" title="CST 1-3 filename Report"></a>CST 1-3 filename Report</h1><h2 id="算法构思-1"><a href="#算法构思-1" class="headerlink" title="算法构思"></a>算法构思</h2><p>因为“插入字符”和“删除字符”操作实际上是可以交换顺序的，所以每种从A到B之间的变换，实际上都可以转换成从A删除字符到A和B的某个公共子序列，然后再插入字符直到得到B。要求k步内能否从A变成B，实际上就是用动态规划方法求A和B最长公共子序列的问题。</p><h2 id="实现过程中遇到的问题"><a href="#实现过程中遇到的问题" class="headerlink" title="实现过程中遇到的问题"></a>实现过程中遇到的问题</h2><p>具体实现时需要解决以下几个问题：1.由于500000*500000会超过存储空间范围，查询网络后发现可以采用滚动数组方法，转换为2*500000大小的数组。2.使用一般的求公共子序列算法会超时，但考虑到k步的限制，所以每次不需要枚举500000次，而只需要看$((n &gt; m ? n - m : m - n) + k) / 2 + 1$范围内即可（相当于只用看对角线附近的）。</p><h2 id="时间和空间复杂度的估算-1"><a href="#时间和空间复杂度的估算-1" class="headerlink" title="时间和空间复杂度的估算"></a>时间和空间复杂度的估算</h2><p><strong>时间复杂度：</strong>DP是算法的关键，时间复杂度为 $O(kn)$（不妨令n&gt;m，$ n \leq 501000 $）</p><p><strong>空间复杂度：</strong>主要占用空间的为memo数组，大小为2*501010，和两个长为501000的char数组，因此算法空间复杂度为$O(n)$</p>]]></content>
    
    
    
    <tags>
      
      <tag>DSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2018/01/05/hello-world/"/>
    <url>/2018/01/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
